shadow$provide[87]=function(r,l,A,p){var k=l(0),m=l(79),d=l(72),c=l(85),a=l(84),b=l(86);const e={5126:4,5123:2,5121:1};let g=0;const f={Float32Array,Uint32Array,Int32Array,Uint8Array,Uint16Array};class h{constructor(n=[],q={}){this.buffers=n;this.indexBuffer=null;this.attributes=q;this.glVertexArrayObjects={};this.id=g++;this.instanced=!1;this.instanceCount=1;this.disposeRunner=new m.Runner("disposeGeometry");this.refCount=0}addAttribute(n,q,t=0,u=!1,v,x,z,y=!1){if(!q)throw Error("You must pass a buffer when creating an attribute");
q instanceof a.Buffer||(q instanceof Array&&(q=new Float32Array(q)),q=new a.Buffer(q));var C=n.split("|");if(1<C.length){for(n=0;n<C.length;n++)this.addAttribute(C[n],q,t,u,v);return this}C=this.buffers.indexOf(q);return-1===C&&(this.buffers.push(q),C=this.buffers.length-1),this.attributes[n]=new c.Attribute(C,t,u,v,x,z,y),this.instanced=this.instanced||y,this}getAttribute(n){return this.attributes[n]}getBuffer(n){return this.buffers[this.getAttribute(n).buffer]}addIndex(n){return n instanceof a.Buffer||
(n instanceof Array&&(n=new Uint16Array(n)),n=new a.Buffer(n)),n.type=k.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER,this.indexBuffer=n,this.buffers.includes(n)||this.buffers.push(n),this}getIndex(){return this.indexBuffer}interleave(){if(1===this.buffers.length||2===this.buffers.length&&this.indexBuffer)return this;const n=[],q=[],t=new a.Buffer;let u;for(u in this.attributes){const v=this.attributes[u];n.push(this.buffers[v.buffer].data);q.push(v.size*e[v.type]/4);v.buffer=0}t.data=b.interleaveTypedArrays(n,
q);for(u=0;u<this.buffers.length;u++)this.buffers[u]!==this.indexBuffer&&this.buffers[u].destroy();return this.buffers=[t],this.indexBuffer&&this.buffers.push(this.indexBuffer),this}getSize(){for(var n in this.attributes)return n=this.attributes[n],this.buffers[n.buffer].data.length/(n.stride/4||n.size);return 0}dispose(){this.disposeRunner.emit(this,!1)}destroy(){this.dispose();this.attributes=this.indexBuffer=this.buffers=null}clone(){const n=new h;for(var q=0;q<this.buffers.length;q++)n.buffers[q]=
new a.Buffer(this.buffers[q].data.slice(0));for(const t in this.attributes)q=this.attributes[t],n.attributes[t]=new c.Attribute(q.buffer,q.size,q.normalized,q.type,q.stride,q.start,q.instance);return this.indexBuffer&&(n.indexBuffer=n.buffers[this.buffers.indexOf(this.indexBuffer)],n.indexBuffer.type=k.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER),n}static merge(n){const q=new h;var t=[],u=[],v=[];for(var x=0;x<n.length;x++){var z=n[x];for(var y=0;y<z.buffers.length;y++)u[y]=u[y]||0,u[y]+=z.buffers[y].data.length,
v[y]=0}for(x=0;x<z.buffers.length;x++)t[x]=new (f[d.getBufferType(z.buffers[x].data)])(u[x]),q.buffers[x]=new a.Buffer(t[x]);for(u=0;u<n.length;u++)for(z=n[u],x=0;x<z.buffers.length;x++)t[x].set(z.buffers[x].data,v[x]),v[x]+=z.buffers[x].data.length;if(q.attributes=z.attributes,z.indexBuffer){q.indexBuffer=q.buffers[z.buffers.indexOf(z.indexBuffer)];q.indexBuffer.type=k.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;x=u=v=t=0;for(y=0;y<z.buffers.length;y++)if(z.buffers[y]!==z.indexBuffer){x=y;break}for(var C in z.attributes)y=
z.attributes[C],(y.buffer|0)===x&&(v+=y.size*e[y.type]/4);for(z=0;z<n.length;z++){C=n[z].indexBuffer.data;for(y=0;y<C.length;y++)q.indexBuffer.data[y+u]+=t;t+=n[z].buffers[x].data.length/v;u+=C.length}}return q}}p.Geometry=h}
goog.provide("module$node_modules$$pixi$core$lib$geometry$Geometry");
goog.global. module$node_modules$$pixi$core$lib$geometry$Geometry=shadow.js.require(87, {});
