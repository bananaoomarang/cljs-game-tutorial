shadow$provide[166]=function(r,l,A,p){function k(g,f,h,n,q){h.buffer.update(q)}function m(g){g=g.map(q=>({data:q,offset:0,dataLen:0,dirty:0}));let f=0,h=0,n=0;for(let q=0;q<g.length;q++){const t=g[q];if(f=e[t.data.type],1<t.data.size&&(f=Math.max(f,16)*t.data.size),t.dataLen=f,0!==h%f&&16>h){const u=h%f%16;h+=u;n+=u}16<h+f?(n=16*Math.ceil(n/16),t.offset=n,n+=f,h=f):(t.offset=n,h+=f,n+=f)}return n=16*Math.ceil(n/16),{uboElements:g,size:n}}function d(g,f){const h=[];for(const n in g)f[n]&&h.push(f[n]);
return h.sort((n,q)=>n.index-q.index),h}l(116);var c=l(107),a=l(112);const b={float:"\n        data[offset] \x3d v;\n    ",vec2:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n    ",vec3:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n        data[offset+2] \x3d v[2];\n\n    ",vec4:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n        data[offset+2] \x3d v[2];\n        data[offset+3] \x3d v[3];\n    ",mat2:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n\n        data[offset+4] \x3d v[2];\n        data[offset+5] \x3d v[3];\n    ",
mat3:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n        data[offset+2] \x3d v[2];\n\n        data[offset + 4] \x3d v[3];\n        data[offset + 5] \x3d v[4];\n        data[offset + 6] \x3d v[5];\n\n        data[offset + 8] \x3d v[6];\n        data[offset + 9] \x3d v[7];\n        data[offset + 10] \x3d v[8];\n    ",mat4:"\n        for(var i \x3d 0; i \x3c 16; i++)\n        {\n            data[offset + i] \x3d v[i];\n        }\n    "},e={float:4,vec2:8,vec3:12,vec4:16,int:4,
ivec2:8,ivec3:12,ivec4:16,uint:4,uvec2:8,uvec3:12,uvec4:16,bool:4,bvec2:8,bvec3:12,bvec4:16,mat2:32,mat3:48,mat4:64};p.createUBOElements=m;p.generateUniformBufferSync=function(g,f){if(!g.autoManage)return{size:0,syncFunc:k};f=d(g.uniforms,f);const {uboElements:h,size:n}=m(f);f=["\n    var v \x3d null;\n    var v2 \x3d null;\n    var cv \x3d null;\n    var t \x3d 0;\n    var gl \x3d renderer.gl\n    var index \x3d 0;\n    var data \x3d buffer.data;\n    "];for(let u=0;u<h.length;u++){const v=h[u];
var q=g.uniforms[v.data.name];const x=v.data.name;var t=!1;for(let z=0;z<c.uniformParsers.length;z++){const y=c.uniformParsers[z];if(y.codeUbo&&y.test(v.data,q)){f.push(`offset = ${v.offset/4};`,c.uniformParsers[z].codeUbo(v.data.name,q));t=!0;break}}t||(1<v.data.size?(t=a.mapSize(v.data.type),q=Math.max(e[v.data.type]/16,1),t/=q,f.push(`
                cv = ud.${x}.value;
                v = uv.${x};
                offset = ${v.offset/4};

                t = 0;

                for(var i=0; i < ${v.data.size*q}; i++)
                {
                    for(var j = 0; j < ${t}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${(4-t%4)%4};
                }

                `)):f.push(`
                cv = ud.${x}.value;
                v = uv.${x};
                offset = ${v.offset/4};
                ${b[v.data.type]};
                `))}return f.push("\n       renderer.buffer.update(buffer);\n    "),{size:n,syncFunc:new Function("ud","uv","renderer","syncData","buffer",f.join("\n"))}};p.getUBOData=d}
goog.provide("module$node_modules$$pixi$core$lib$shader$utils$generateUniformBufferSync");
goog.global. module$node_modules$$pixi$core$lib$shader$utils$generateUniformBufferSync=shadow.js.require(166, {});
