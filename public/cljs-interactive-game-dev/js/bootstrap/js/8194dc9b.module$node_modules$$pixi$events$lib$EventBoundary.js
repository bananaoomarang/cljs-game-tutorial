shadow$provide[248]=function(r,l,A,p){var k=l(209),m=l(243),d=l(245),c=l(246),a=l(247);const b=new k.Point,e=new k.Point;class g{constructor(f){this.dispatch=new k.utils.EventEmitter;this.moveOnAll=!1;this.enableGlobalMoveEvents=!0;this.mappingState={trackingData:{}};this.eventPool=new Map;this._allInteractiveElements=[];this._hitElements=[];this._isPointerMoveEvent=!1;this.rootTarget=f;this.hitPruneFn=this.hitPruneFn.bind(this);this.hitTestFn=this.hitTestFn.bind(this);this.mapPointerDown=this.mapPointerDown.bind(this);
this.mapPointerMove=this.mapPointerMove.bind(this);this.mapPointerOut=this.mapPointerOut.bind(this);this.mapPointerOver=this.mapPointerOver.bind(this);this.mapPointerUp=this.mapPointerUp.bind(this);this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this);this.mapWheel=this.mapWheel.bind(this);this.mappingTable={};this.addEventMapping("pointerdown",this.mapPointerDown);this.addEventMapping("pointermove",this.mapPointerMove);this.addEventMapping("pointerout",this.mapPointerOut);this.addEventMapping("pointerleave",
this.mapPointerOut);this.addEventMapping("pointerover",this.mapPointerOver);this.addEventMapping("pointerup",this.mapPointerUp);this.addEventMapping("pointerupoutside",this.mapPointerUpOutside);this.addEventMapping("wheel",this.mapWheel)}addEventMapping(f,h){this.mappingTable[f]||(this.mappingTable[f]=[]);this.mappingTable[f].push({fn:h,priority:0});this.mappingTable[f].sort((n,q)=>n.priority-q.priority)}dispatchEvent(f,h){f.propagationStopped=!1;f.propagationImmediatelyStopped=!1;this.propagate(f,
h);this.dispatch.emit(h||f.type,f)}mapEvent(f){if(this.rootTarget){var h=this.mappingTable[f.type];if(h)for(let n=0,q=h.length;n<q;n++)h[n].fn(f);else console.warn(`[EventBoundary]: Event mapping not defined for ${f.type}`)}}hitTest(f,h){m.EventsTicker.pauseUpdate=!0;return(f=this[this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive"](this.rootTarget,this.rootTarget.eventMode,b.set(f,h),this.hitTestFn,this.hitPruneFn))&&f[0]}propagate(f,h){if(f.target){var n=
f.composedPath();f.eventPhase=f.CAPTURING_PHASE;for(let q=0,t=n.length-1;q<t;q++)if(f.currentTarget=n[q],this.notifyTarget(f,h),f.propagationStopped||f.propagationImmediatelyStopped)return;if(f.eventPhase=f.AT_TARGET,f.currentTarget=f.target,this.notifyTarget(f,h),!f.propagationStopped&&!f.propagationImmediatelyStopped){f.eventPhase=f.BUBBLING_PHASE;for(let q=n.length-2;0<=q&&(f.currentTarget=n[q],this.notifyTarget(f,h),!f.propagationStopped&&!f.propagationImmediatelyStopped);q--);}}}all(f,h,n=this._allInteractiveElements){if(0!==
n.length){f.eventPhase=f.BUBBLING_PHASE;h=Array.isArray(h)?h:[h];for(let q=n.length-1;0<=q;q--)h.forEach(t=>{f.currentTarget=n[q];this.notifyTarget(f,t)})}}propagationPath(f){const h=[f];for(let n=0;2048>n&&f!==this.rootTarget;n++){if(!f.parent)throw Error("Cannot find propagation path to disconnected target");h.push(f.parent);f=f.parent}return h.reverse(),h}hitTestMoveRecursive(f,h,n,q,t,u=!1){var v=!1;if(this._interactivePrune(f))return null;if(("dynamic"===f.eventMode||"dynamic"===h)&&(m.EventsTicker.pauseUpdate=
!1),f.interactiveChildren&&f.children){var x=f.children;for(let y=x.length-1;0<=y;y--){var z=x[y];!(z=this.hitTestMoveRecursive(z,this._isInteractive(h)?h:z.eventMode,n,q,t,u||t(f,n)))||0<z.length&&!z[z.length-1].parent||(v=f.isInteractive(),(0<z.length||v)&&(v&&this._allInteractiveElements.push(f),z.push(f)),0===this._hitElements.length&&(this._hitElements=z),v=!0)}}h=this._isInteractive(h);x=f.isInteractive();return h&&x&&this._allInteractiveElements.push(f),u||0<this._hitElements.length?null:v?
this._hitElements:h&&!t(f,n)&&q(f,n)?x?[f]:[]:null}hitTestRecursive(f,h,n,q,t){if(this._interactivePrune(f)||t(f,n))return null;if(("dynamic"===f.eventMode||"dynamic"===h)&&(m.EventsTicker.pauseUpdate=!1),f.interactiveChildren&&f.children){const v=f.children;for(let x=v.length-1;0<=x;x--){var u=v[x];if((u=this.hitTestRecursive(u,this._isInteractive(h)?h:u.eventMode,n,q,t))&&(!(0<u.length)||u[u.length-1].parent))return n=f.isInteractive(),(0<u.length||n)&&u.push(f),u}}h=this._isInteractive(h);t=f.isInteractive();
return h&&q(f,n)?t?[f]:[]:null}_isInteractive(f){return"static"===f||"dynamic"===f}_interactivePrune(f){return!(f&&!f.isMask&&f.visible&&f.renderable&&"none"!==f.eventMode&&("passive"!==f.eventMode||f.interactiveChildren)&&!f.isMask)}hitPruneFn(f,h){return f.hitArea&&(f.worldTransform.applyInverse(h,e),!f.hitArea.contains(e.x,e.y))||f._mask&&(f=f._mask.isMaskData?f._mask.maskObject:f._mask)&&!f.containsPoint?.(h)?!0:!1}hitTestFn(f,h){return"passive"===f.eventMode?!1:f.hitArea?!0:f.containsPoint?f.containsPoint(h):
!1}notifyTarget(f,h){h=h??f.type;f.currentTarget[`on${h}`]?.(f);this.notifyListeners(f,f.eventPhase===f.CAPTURING_PHASE||f.eventPhase===f.AT_TARGET?`${h}capture`:h);f.eventPhase===f.AT_TARGET&&this.notifyListeners(f,h)}mapPointerDown(f){if(f instanceof c.FederatedPointerEvent){var h=this.createPointerEvent(f);(this.dispatchEvent(h,"pointerdown"),"touch"===h.pointerType)?this.dispatchEvent(h,"touchstart"):("mouse"===h.pointerType||"pen"===h.pointerType)&&this.dispatchEvent(h,2===h.button?"rightdown":
"mousedown");this.trackingData(f.pointerId).pressTargetsByButton[f.button]=h.composedPath();this.freeEvent(h)}else console.warn("EventBoundary cannot map a non-pointer event as a pointer event")}mapPointerMove(f){if(f instanceof c.FederatedPointerEvent){this._allInteractiveElements.length=0;this._hitElements.length=0;this._isPointerMoveEvent=!0;var h=this.createPointerEvent(f);this._isPointerMoveEvent=!1;var n="mouse"===h.pointerType||"pen"===h.pointerType,q=this.trackingData(f.pointerId),t=this.findMountedTarget(q.overTargets);
if(0<q.overTargets?.length&&t!==h.target){var u=this.createPointerEvent(f,"mousemove"===f.type?"mouseout":"pointerout",t);if(this.dispatchEvent(u,"pointerout"),n&&this.dispatchEvent(u,"mouseout"),!h.composedPath().includes(t)){const v=this.createPointerEvent(f,"pointerleave",t);for(v.eventPhase=v.AT_TARGET;v.target&&!h.composedPath().includes(v.target);)v.currentTarget=v.target,this.notifyTarget(v),n&&this.notifyTarget(v,"mouseleave"),v.target=v.target.parent;this.freeEvent(v)}this.freeEvent(u)}if(t!==
h.target){f=this.clonePointerEvent(h,"mousemove"===f.type?"mouseover":"pointerover");this.dispatchEvent(f,"pointerover");n&&this.dispatchEvent(f,"mouseover");for(u=t?.parent;u&&u!==this.rootTarget.parent&&u!==h.target;)u=u.parent;if(!u||u===this.rootTarget.parent){u=this.clonePointerEvent(h,"pointerenter");for(u.eventPhase=u.AT_TARGET;u.target&&u.target!==t&&u.target!==this.rootTarget.parent;)u.currentTarget=u.target,this.notifyTarget(u),n&&this.notifyTarget(u,"mouseenter"),u.target=u.target.parent;
this.freeEvent(u)}this.freeEvent(f)}t=[];f=this.enableGlobalMoveEvents??!0;this.moveOnAll?t.push("pointermove"):this.dispatchEvent(h,"pointermove");f&&t.push("globalpointermove");"touch"===h.pointerType&&(this.moveOnAll?t.splice(1,0,"touchmove"):this.dispatchEvent(h,"touchmove"),f&&t.push("globaltouchmove"));n&&(this.moveOnAll?t.splice(1,0,"mousemove"):this.dispatchEvent(h,"mousemove"),f&&t.push("globalmousemove"),this.cursor=h.target?.cursor);0<t.length&&this.all(h,t);this._allInteractiveElements.length=
0;this._hitElements.length=0;q.overTargets=h.composedPath();this.freeEvent(h)}else console.warn("EventBoundary cannot map a non-pointer event as a pointer event")}mapPointerOver(f){if(f instanceof c.FederatedPointerEvent){var h=this.trackingData(f.pointerId);f=this.createPointerEvent(f);var n="mouse"===f.pointerType||"pen"===f.pointerType;this.dispatchEvent(f,"pointerover");n&&this.dispatchEvent(f,"mouseover");"mouse"===f.pointerType&&(this.cursor=f.target?.cursor);var q=this.clonePointerEvent(f,
"pointerenter");for(q.eventPhase=q.AT_TARGET;q.target&&q.target!==this.rootTarget.parent;)q.currentTarget=q.target,this.notifyTarget(q),n&&this.notifyTarget(q,"mouseenter"),q.target=q.target.parent;h.overTargets=f.composedPath();this.freeEvent(f);this.freeEvent(q)}else console.warn("EventBoundary cannot map a non-pointer event as a pointer event")}mapPointerOut(f){if(f instanceof c.FederatedPointerEvent){var h=this.trackingData(f.pointerId);if(h.overTargets){const n="mouse"===f.pointerType||"pen"===
f.pointerType,q=this.findMountedTarget(h.overTargets),t=this.createPointerEvent(f,"pointerout",q);this.dispatchEvent(t);n&&this.dispatchEvent(t,"mouseout");f=this.createPointerEvent(f,"pointerleave",q);for(f.eventPhase=f.AT_TARGET;f.target&&f.target!==this.rootTarget.parent;)f.currentTarget=f.target,this.notifyTarget(f),n&&this.notifyTarget(f,"mouseleave"),f.target=f.target.parent;h.overTargets=null;this.freeEvent(t);this.freeEvent(f)}this.cursor=null}else console.warn("EventBoundary cannot map a non-pointer event as a pointer event")}mapPointerUp(f){if(f instanceof
c.FederatedPointerEvent){var h=performance.now(),n=this.createPointerEvent(f);(this.dispatchEvent(n,"pointerup"),"touch"===n.pointerType)?this.dispatchEvent(n,"touchend"):("mouse"===n.pointerType||"pen"===n.pointerType)&&this.dispatchEvent(n,2===n.button?"rightup":"mouseup");var q=this.trackingData(f.pointerId),t=this.findMountedTarget(q.pressTargetsByButton[f.button]),u=t;if(t&&!n.composedPath().includes(t)){for(u=t;u&&!n.composedPath().includes(u);)(n.currentTarget=u,this.notifyTarget(n,"pointerupoutside"),
"touch"===n.pointerType)?this.notifyTarget(n,"touchendoutside"):("mouse"===n.pointerType||"pen"===n.pointerType)&&this.notifyTarget(n,2===n.button?"rightupoutside":"mouseupoutside"),u=u.parent;delete q.pressTargetsByButton[f.button]}u&&(t=this.clonePointerEvent(n,"click"),t.target=u,t.path=null,q.clicksByButton[f.button]||(q.clicksByButton[f.button]={clickCount:0,target:t.target,timeStamp:h}),f=q.clicksByButton[f.button],(f.target===t.target&&200>h-f.timeStamp?++f.clickCount:f.clickCount=1,f.target=
t.target,f.timeStamp=h,t.detail=f.clickCount,"mouse"===t.pointerType)?this.dispatchEvent(t,2===t.button?"rightclick":"click"):"touch"===t.pointerType&&this.dispatchEvent(t,"tap"),this.dispatchEvent(t,"pointertap"),this.freeEvent(t));this.freeEvent(n)}else console.warn("EventBoundary cannot map a non-pointer event as a pointer event")}mapPointerUpOutside(f){if(f instanceof c.FederatedPointerEvent){var h=this.trackingData(f.pointerId),n=this.findMountedTarget(h.pressTargetsByButton[f.button]),q=this.createPointerEvent(f);
if(n){for(;n;)q.currentTarget=n,this.notifyTarget(q,"pointerupoutside"),"touch"===q.pointerType?this.notifyTarget(q,"touchendoutside"):("mouse"===q.pointerType||"pen"===q.pointerType)&&this.notifyTarget(q,2===q.button?"rightupoutside":"mouseupoutside"),n=n.parent;delete h.pressTargetsByButton[f.button]}this.freeEvent(q)}else console.warn("EventBoundary cannot map a non-pointer event as a pointer event")}mapWheel(f){f instanceof a.FederatedWheelEvent?(f=this.createWheelEvent(f),this.dispatchEvent(f),
this.freeEvent(f)):console.warn("EventBoundary cannot map a non-wheel event as a wheel event")}findMountedTarget(f){if(!f)return null;let h=f[0];for(let n=1;n<f.length&&f[n].parent===h;n++)h=f[n];return h}createPointerEvent(f,h,n){const q=this.allocateEvent(c.FederatedPointerEvent);return this.copyPointerData(f,q),this.copyMouseData(f,q),this.copyData(f,q),q.nativeEvent=f.nativeEvent,q.originalEvent=f,q.target=n??this.hitTest(q.global.x,q.global.y)??this._hitElements[0],"string"==typeof h&&(q.type=
h),q}createWheelEvent(f){const h=this.allocateEvent(a.FederatedWheelEvent);return this.copyWheelData(f,h),this.copyMouseData(f,h),this.copyData(f,h),h.nativeEvent=f.nativeEvent,h.originalEvent=f,h.target=this.hitTest(h.global.x,h.global.y),h}clonePointerEvent(f,h){const n=this.allocateEvent(c.FederatedPointerEvent);return n.nativeEvent=f.nativeEvent,n.originalEvent=f.originalEvent,this.copyPointerData(f,n),this.copyMouseData(f,n),this.copyData(f,n),n.target=f.target,n.path=f.composedPath().slice(),
n.type=h??n.type,n}copyWheelData(f,h){h.deltaMode=f.deltaMode;h.deltaX=f.deltaX;h.deltaY=f.deltaY;h.deltaZ=f.deltaZ}copyPointerData(f,h){f instanceof c.FederatedPointerEvent&&h instanceof c.FederatedPointerEvent&&(h.pointerId=f.pointerId,h.width=f.width,h.height=f.height,h.isPrimary=f.isPrimary,h.pointerType=f.pointerType,h.pressure=f.pressure,h.tangentialPressure=f.tangentialPressure,h.tiltX=f.tiltX,h.tiltY=f.tiltY,h.twist=f.twist)}copyMouseData(f,h){f instanceof d.FederatedMouseEvent&&h instanceof
d.FederatedMouseEvent&&(h.altKey=f.altKey,h.button=f.button,h.buttons=f.buttons,h.client.copyFrom(f.client),h.ctrlKey=f.ctrlKey,h.metaKey=f.metaKey,h.movement.copyFrom(f.movement),h.screen.copyFrom(f.screen),h.shiftKey=f.shiftKey,h.global.copyFrom(f.global))}copyData(f,h){h.isTrusted=f.isTrusted;h.srcElement=f.srcElement;h.timeStamp=performance.now();h.type=f.type;h.detail=f.detail;h.view=f.view;h.which=f.which;h.layer.copyFrom(f.layer);h.page.copyFrom(f.page)}trackingData(f){return this.mappingState.trackingData[f]||
(this.mappingState.trackingData[f]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[f]}allocateEvent(f){this.eventPool.has(f)||this.eventPool.set(f,[]);f=this.eventPool.get(f).pop()||new f(this);return f.eventPhase=f.NONE,f.currentTarget=null,f.path=null,f.target=null,f}freeEvent(f){if(f.manager!==this)throw Error("It is illegal to free an event not managed by this EventBoundary!");const h=f.constructor;this.eventPool.has(h)||this.eventPool.set(h,[]);this.eventPool.get(h).push(f)}notifyListeners(f,
h){const n=f.currentTarget._events[h];if(n&&f.currentTarget.isInteractive())if("fn"in n)n.once&&f.currentTarget.removeListener(h,n.fn,void 0,!0),n.fn.call(n.context,f);else for(let q=0,t=n.length;q<t&&!f.propagationImmediatelyStopped;q++)n[q].once&&f.currentTarget.removeListener(h,n[q].fn,void 0,!0),n[q].fn.call(n[q].context,f)}}p.EventBoundary=g}
goog.provide("module$node_modules$$pixi$events$lib$EventBoundary");
goog.global. module$node_modules$$pixi$events$lib$EventBoundary=shadow.js.require(248, {});
