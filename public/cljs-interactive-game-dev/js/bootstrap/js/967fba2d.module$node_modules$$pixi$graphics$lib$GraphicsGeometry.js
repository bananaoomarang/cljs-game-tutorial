shadow$provide[335]=function(r,l,A,p){var k=l(209),m=l(214),d=l(334),c=l(333),a=l(329),b=l(324),e=l(331);const g=new k.Point;r=(()=>{const f=class extends k.BatchGeometry{constructor(){super();this.closePointEps=1E-4;this.boundsPadding=0;this.indicesUint16=this.uvsFloat32=null;this.batchable=!1;this.points=[];this.colors=[];this.uvs=[];this.indices=[];this.textureIds=[];this.graphicsData=[];this.drawCalls=[];this.batchDirty=-1;this.batches=[];this.dirty=0;this.cacheDirty=-1;this.shapeIndex=this.clearDirty=
0;this._bounds=new m.Bounds;this.boundsDirty=-1}get bounds(){return this.updateBatches(),this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1;this.dirty++;this.batchDirty++;this.shapeIndex=0;this.points.length=0;this.colors.length=0;this.uvs.length=0;this.indices.length=0;this.textureIds.length=0;for(var h=0;h<this.drawCalls.length;h++)this.drawCalls[h].texArray.clear(),c.DRAW_CALL_POOL.push(this.drawCalls[h]);this.drawCalls.length=
0;for(h=0;h<this.batches.length;h++){const n=this.batches[h];n.reset();c.BATCH_POOL.push(n)}this.batches.length=0}clear(){return 0<this.graphicsData.length&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(h,n=null,q=null,t=null){h=new d.GraphicsData(h,n,q,t);return this.graphicsData.push(h),this.dirty++,this}drawHole(h,n=null){if(!this.graphicsData.length)return null;h=new d.GraphicsData(h,null,null,n);n=this.graphicsData[this.graphicsData.length-1];return h.lineStyle=
n.lineStyle,n.holes.push(h),this.dirty++,this}destroy(){super.destroy();for(let h=0;h<this.graphicsData.length;++h)this.graphicsData[h].destroy();this.points.length=0;this.points=null;this.colors.length=0;this.colors=null;this.uvs.length=0;this.uvs=null;this.indices.length=0;this.indices=null;this.indexBuffer.destroy();this.indexBuffer=null;this.graphicsData.length=0;this.graphicsData=null;this.drawCalls.length=0;this.drawCalls=null;this.batches.length=0;this._bounds=this.batches=null}containsPoint(h){const n=
this.graphicsData;for(let q=0;q<n.length;++q){const t=n[q];if(t.fillStyle.visible&&t.shape&&(t.matrix?t.matrix.applyInverse(h,g):g.copyFrom(h),t.shape.contains(g.x,g.y))){let u=!1;if(t.holes)for(let v=0;v<t.holes.length;v++)if(t.holes[v].shape.contains(g.x,g.y)){u=!0;break}if(!u)return!0}}return!1}updateBatches(){if(!this.graphicsData.length)this.batchable=!0;else if(this.validateBatching()){this.cacheDirty=this.dirty;var h=this.uvs,n=this.graphicsData,q=null,t=null;0<this.batches.length&&(q=this.batches[this.batches.length-
1],t=q.style);for(let u=this.shapeIndex;u<n.length;u++){this.shapeIndex++;const v=n[u],x=v.fillStyle,z=v.lineStyle;c.FILL_COMMANDS[v.type].build(v);v.matrix&&this.transformPoints(v.points,v.matrix);(x.visible||z.visible)&&this.processHoles(v.holes);for(let y=0;2>y;y++){const C=0===y?x:z;if(!C.visible)continue;const B=this.indices.length,w=this.points.length/2;C.texture.baseTexture.wrapMode=k.WRAP_MODES.REPEAT;0===y?this.processFill(v):this.processLine(v);const E=this.points.length/2-w;0!==E&&(q&&
!this._compareStyles(t,C)&&(q.end(B,w),q=null),q||(q=c.BATCH_POOL.pop()||new a.BatchPart,q.begin(C,B,w),this.batches.push(q),t=C),this.addUvs(this.points,h,C.texture,w,E,C.matrix))}}h=this.indices.length;n=this.points.length/2;(q&&q.end(h,n),0===this.batches.length)?this.batchable=!0:(q=65535<n,this.indicesUint16&&this.indices.length===this.indicesUint16.length&&q===2<this.indicesUint16.BYTES_PER_ELEMENT?this.indicesUint16.set(this.indices):this.indicesUint16=q?new Uint32Array(this.indices):new Uint16Array(this.indices),
(this.batchable=this.isBatchable())?this.packBatches():this.buildDrawCalls())}}_compareStyles(h,n){return!(!h||!n||h.texture.baseTexture!==n.texture.baseTexture||h.color+h.alpha!==n.color+n.alpha||!!h.native!=!!n.native)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let n=0,q=this.graphicsData.length;n<q;n++){var h=this.graphicsData[n];const t=h.fillStyle;h=h.lineStyle;if(t&&!t.texture.baseTexture.valid||h&&!h.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++;
this.uvsFloat32=new Float32Array(this.uvs);const h=this.batches;for(let n=0,q=h.length;n<q;n++){const t=h[n];for(let u=0;u<t.size;u++){const v=t.start+u;this.indicesUint16[v]-=t.attribStart}}}isBatchable(){if(131070<this.points.length)return!1;const h=this.batches;for(let n=0;n<h.length;n++)if(h[n].style.native)return!1;return this.points.length<2*f.BATCHABLE_SIZE}buildDrawCalls(){let h=++k.BaseTexture._globalBatch;for(var n=0;n<this.drawCalls.length;n++)this.drawCalls[n].texArray.clear(),c.DRAW_CALL_POOL.push(this.drawCalls[n]);
this.drawCalls.length=0;n=this.colors;const q=this.textureIds;let t=c.DRAW_CALL_POOL.pop();t||(t=new k.BatchDrawCall,t.texArray=new k.BatchTextureArray);t.texArray.count=0;t.start=0;t.size=0;t.type=k.DRAW_MODES.TRIANGLES;let u=0,v=null;let x=!1,z=k.DRAW_MODES.TRIANGLES,y=0;this.drawCalls.push(t);for(let B=0;B<this.batches.length;B++){const w=this.batches[B],E=w.style;var C=E.texture.baseTexture;x!==!!E.native&&(x=!!E.native,z=x?k.DRAW_MODES.LINES:k.DRAW_MODES.TRIANGLES,v=null,u=8,h++);v!==C&&(v=C,
C._batchEnabled!==h&&(8===u&&(h++,u=0,0<t.size&&(t=c.DRAW_CALL_POOL.pop(),t||(t=new k.BatchDrawCall,t.texArray=new k.BatchTextureArray),this.drawCalls.push(t)),t.start=y,t.size=0,t.texArray.count=0,t.type=z),C.touched=1,C._batchEnabled=h,C._batchLocation=u,C.wrapMode=k.WRAP_MODES.REPEAT,t.texArray.elements[t.texArray.count++]=C,u++));t.size+=w.size;y+=w.size;C=C._batchLocation;this.addColors(n,E.color,E.alpha,w.attribSize,w.attribStart);this.addTextureIds(q,C,w.attribSize,w.attribStart)}k.BaseTexture._globalBatch=
h;this.packAttributes()}packAttributes(){const h=this.points,n=this.uvs,q=this.colors,t=this.textureIds,u=new ArrayBuffer(12*h.length),v=new Float32Array(u),x=new Uint32Array(u);let z=0;for(let y=0;y<h.length/2;y++)v[z++]=h[2*y],v[z++]=h[2*y+1],v[z++]=n[2*y],v[z++]=n[2*y+1],x[z++]=q[y],v[z++]=t[y];this._buffer.update(u);this._indexBuffer.update(this.indicesUint16)}processFill(h){h.holes.length?b.buildPoly.triangulate(h,this):c.FILL_COMMANDS[h.type].triangulate(h,this)}processLine(h){e.buildLine(h,
this);for(let n=0;n<h.holes.length;n++)e.buildLine(h.holes[n],this)}processHoles(h){for(let n=0;n<h.length;n++){const q=h[n];c.FILL_COMMANDS[q.type].build(q);q.matrix&&this.transformPoints(q.points,q.matrix)}}calculateBounds(){const h=this._bounds;h.clear();h.addVertexData(this.points,0,this.points.length);h.pad(this.boundsPadding,this.boundsPadding)}transformPoints(h,n){for(let q=0;q<h.length/2;q++){const t=h[2*q],u=h[2*q+1];h[2*q]=n.a*t+n.c*u+n.tx;h[2*q+1]=n.b*t+n.d*u+n.ty}}addColors(h,n,q,t,u=
0){n=k.Color.shared.setValue(n).toLittleEndianNumber();q=k.Color.shared.setValue(n).toPremultiplied(q);h.length=Math.max(h.length,u+t);for(n=0;n<t;n++)h[u+n]=q}addTextureIds(h,n,q,t=0){h.length=Math.max(h.length,t+q);for(let u=0;u<q;u++)h[t+u]=n}addUvs(h,n,q,t,u,v=null){let x=0;const z=n.length,y=q.frame;for(;x<u;){let C=h[2*(t+x)],B=h[2*(t+x)+1];if(v){const w=v.a*C+v.c*B+v.tx;B=v.b*C+v.d*B+v.ty;C=w}x++;n.push(C/y.width,B/y.height)}h=q.baseTexture;(y.width<h.width||y.height<h.height)&&this.adjustUvs(n,
q,z,u)}adjustUvs(h,n,q,t){var u=n.baseTexture;t=q+2*t;var v=n.frame;n=v.width/u.width;u=v.height/u.height;let x=v.x/v.width;v=v.y/v.height;let z=Math.floor(h[q]+1E-6),y=Math.floor(h[q+1]+1E-6);for(let C=q+2;C<t;C+=2)z=Math.min(z,Math.floor(h[C]+1E-6)),y=Math.min(y,Math.floor(h[C+1]+1E-6));x-=z;for(v-=y;q<t;q+=2)h[q]=(h[q]+x)*n,h[q+1]=(h[q+1]+v)*u}};return f})();r.BATCHABLE_SIZE=100;p.GraphicsGeometry=r}
goog.provide("module$node_modules$$pixi$graphics$lib$GraphicsGeometry");
goog.global. module$node_modules$$pixi$graphics$lib$GraphicsGeometry=shadow.js.require(335, {});
