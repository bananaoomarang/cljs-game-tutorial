shadow$provide[165]=function(r,l,A,p){var k=l(162),m=l(105),d=l(106),c=l(163),a=l(164),b=l(111);p.generateProgram=function(e,g){var f=m.compileShader(e,e.VERTEX_SHADER,g.vertexSrc),h=m.compileShader(e,e.FRAGMENT_SHADER,g.fragmentSrc);const n=e.createProgram();e.attachShader(n,f);e.attachShader(n,h);var q=g.extra?.transformFeedbackVaryings;if(q&&("function"!=typeof e.transformFeedbackVaryings?console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given."):e.transformFeedbackVaryings(n,
q.names,"separate"===q.bufferMode?e.SEPARATE_ATTRIBS:e.INTERLEAVED_ATTRIBS)),e.linkProgram(n),e.getProgramParameter(n,e.LINK_STATUS)||b.logProgramError(e,n,f,h),g.attributeData=c.getAttributeData(n,e),g.uniformData=a.getUniformData(n,e),!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(g.vertexSrc)){q=Object.keys(g.attributeData);q.sort((t,u)=>t>u?1:-1);for(let t=0;t<q.length;t++)g.attributeData[q[t]].location=t,e.bindAttribLocation(n,t,q[t]);e.linkProgram(n)}e.deleteShader(f);e.deleteShader(h);
f={};for(const t in g.uniformData)h=g.uniformData[t],f[t]={location:e.getUniformLocation(n,t),value:d.defaultValue(h.type,h.size)};return new k.GLProgram(n,f)}}
goog.provide("module$node_modules$$pixi$core$lib$shader$utils$generateProgram");
goog.global. module$node_modules$$pixi$core$lib$shader$utils$generateProgram=shadow.js.require(165, {});
