shadow$provide[278]=function(r,l,A,p){async function k(f){const h=await m.settings.ADAPTER.fetch(f);if(!h.ok)throw Error(`[loadImageBitmap] Failed to fetch ${f}: ${h.status} ${h.statusText}`);f=await h.blob();return await createImageBitmap(f)}var m=l(209),d=l(261),c=l(262);r=l(270);var a=l(276),b=l(277);const e=[".jpeg",".jpg",".png",".webp",".avif"],g=["image/jpeg","image/png","image/webp","image/avif"];l={name:"loadTextures",extension:{type:m.ExtensionType.LoadParser,priority:r.LoaderParserPriority.High},
config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(f){return d.checkDataUrl(f,g)||c.checkExtension(f,e)},async load(f,h,n){var q=globalThis.createImageBitmap&&this.config.preferCreateImageBitmap;let t;q?this.config.preferWorkers&&await a.WorkerManager.isImageBitmapSupported()?t=await a.WorkerManager.loadImageBitmap(f):t=await k(f):t=await new Promise((u,v)=>{const x=new Image;x.crossOrigin=this.config.crossOrigin;x.src=f;x.complete?u(x):(x.onload=()=>u(x),x.onerror=
z=>v(z))});h={...h.data};h.resolution??(h.resolution=m.utils.getResolutionOfUrl(f));q&&void 0===h.resourceOptions?.ownsImageBitmap&&(h.resourceOptions={...h.resourceOptions},h.resourceOptions.ownsImageBitmap=!0);q=new m.BaseTexture(t,h);return q.resource.src=f,b.createTexture(q,n,f)},unload(f){f.destroy(!0)}};m.extensions.add(l);p.loadImageBitmap=k;p.loadTextures=l}
goog.provide("module$node_modules$$pixi$assets$lib$loader$parsers$textures$loadTextures");
goog.global. module$node_modules$$pixi$assets$lib$loader$parsers$textures$loadTextures=shadow.js.require(278, {});
