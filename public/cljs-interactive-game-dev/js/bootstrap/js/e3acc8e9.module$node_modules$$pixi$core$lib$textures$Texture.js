shadow$provide[139]=function(r,l,A,p){function k(h){h.destroy=function(){};h.on=function(){};h.once=function(){};h.emit=function(){}}var m=l(102),d=l(8),c=l(72),a=l(82),b=l(137),e=l(138);const g=new e.TextureUvs;class f extends c.EventEmitter{constructor(h,n,q,t,u,v,x){if(super(),this.noFrame=!1,n||(this.noFrame=!0,n=new m.Rectangle(0,0,1,1)),h instanceof f&&(h=h.baseTexture),this.baseTexture=h,this._frame=n,this.trim=t,this.valid=!1,this.destroyed=!1,this._uvs=g,this.uvMatrix=null,this.orig=q||n,
this._rotate=Number(u||0),!0===u)this._rotate=2;else if(0!==this._rotate%2)throw Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");this.defaultAnchor=v?new m.Point(v.x,v.y):new m.Point(0,0);this.defaultBorders=x;this._updateID=0;this.textureCacheIds=[];h.valid?this.noFrame?h.valid&&this.onBaseTextureUpdated(h):this.frame=n:h.once("loaded",this.onBaseTextureUpdated,this);this.noFrame&&h.on("update",this.onBaseTextureUpdated,this)}update(){this.baseTexture.resource&&
this.baseTexture.resource.update()}onBaseTextureUpdated(h){if(this.noFrame){if(!this.baseTexture.valid)return;this._frame.width=h.width;this._frame.height=h.height;this.valid=!0;this.updateUvs()}else this.frame=this._frame;this.emit("update",this)}destroy(h){this.baseTexture&&(h&&({resource:h}=this.baseTexture,h?.url&&c.TextureCache[h.url]&&f.removeFromCache(h.url),this.baseTexture.destroy()),this.baseTexture.off("loaded",this.onBaseTextureUpdated,this),this.baseTexture.off("update",this.onBaseTextureUpdated,
this),this.baseTexture=null);this.orig=this.trim=this._uvs=this._frame=null;this.valid=!1;f.removeFromCache(this);this.textureCacheIds=null;this.destroyed=!0;this.emit("destroyed",this);this.removeAllListeners()}clone(){const h=this._frame.clone();var n=this._frame===this.orig?h:this.orig.clone();n=new f(this.baseTexture,!this.noFrame&&h,n,this.trim?.clone(),this.rotate,this.defaultAnchor,this.defaultBorders);return this.noFrame&&(n._frame=h),n}updateUvs(){this._uvs===g&&(this._uvs=new e.TextureUvs);
this._uvs.set(this._frame,this.baseTexture,this.rotate);this._updateID++}static from(h,n={},q=d.settings.STRICT_TEXTURE_CACHE){const t="string"==typeof h;let u;t?u=h:h instanceof a.BaseTexture?(h.cacheId||(h.cacheId=`${n?.pixiIdPrefix||"pixiid"}-${c.uid()}`,a.BaseTexture.addToCache(h,h.cacheId)),u=h.cacheId):(h._pixiId||(h._pixiId=`${n?.pixiIdPrefix||"pixiid"}_${c.uid()}`),u=h._pixiId);let v=c.TextureCache[u];if(t&&q&&!v)throw Error(`The cacheId "${u}" does not exist in TextureCache.`);return v||
h instanceof a.BaseTexture?!v&&h instanceof a.BaseTexture&&(v=new f(h),f.addToCache(v,u)):(n.resolution||(n.resolution=c.getResolutionOfUrl(h)),v=new f(new a.BaseTexture(h,n)),v.baseTexture.cacheId=u,a.BaseTexture.addToCache(v.baseTexture,u),f.addToCache(v,u)),v}static fromURL(h,n){const q=Object.assign({autoLoad:!1},n?.resourceOptions),t=f.from(h,Object.assign({resourceOptions:q},n),!1);h=t.baseTexture.resource;return t.baseTexture.valid?Promise.resolve(t):h.load().then(()=>Promise.resolve(t))}static fromBuffer(h,
n,q,t){return new f(a.BaseTexture.fromBuffer(h,n,q,t))}static fromLoader(h,n,q,t){h=new a.BaseTexture(h,Object.assign({scaleMode:a.BaseTexture.defaultOptions.scaleMode,resolution:c.getResolutionOfUrl(n)},t));({resource:t}=h);t instanceof b.ImageResource&&(t.url=n);const u=new f(h);return q||(q=n),a.BaseTexture.addToCache(u.baseTexture,q),f.addToCache(u,q),q!==n&&(a.BaseTexture.addToCache(u.baseTexture,n),f.addToCache(u,n)),u.baseTexture.valid?Promise.resolve(u):new Promise(v=>{u.baseTexture.once("loaded",
()=>v(u))})}static addToCache(h,n){n&&(h.textureCacheIds.includes(n)||h.textureCacheIds.push(n),c.TextureCache[n]&&c.TextureCache[n]!==h&&console.warn(`Texture added to the cache with an id [${n}] that already had an entry`),c.TextureCache[n]=h)}static removeFromCache(h){if("string"==typeof h){var n=c.TextureCache[h];if(n){const q=n.textureCacheIds.indexOf(h);return-1<q&&n.textureCacheIds.splice(q,1),delete c.TextureCache[h],n}}else if(h?.textureCacheIds){for(n=0;n<h.textureCacheIds.length;++n)c.TextureCache[h.textureCacheIds[n]]===
h&&delete c.TextureCache[h.textureCacheIds[n]];return h.textureCacheIds.length=0,h}return null}get resolution(){return this.baseTexture.resolution}get frame(){return this._frame}set frame(h){this._frame=h;this.noFrame=!1;const {x:n,y:q,width:t,height:u}=h,v=n+t>this.baseTexture.width,x=q+u>this.baseTexture.height;if(v||x)throw Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${`X: ${n} + ${t} = ${n+t} > ${this.baseTexture.width}`} ${v&&x?"and":"or"} ${`Y: ${q} + ${u} = ${q+
u} > ${this.baseTexture.height}`}`);this.valid=t&&u&&this.baseTexture.valid;this.trim||this.rotate||(this.orig=h);this.valid&&this.updateUvs()}get rotate(){return this._rotate}set rotate(h){this._rotate=h;this.valid&&this.updateUvs()}get width(){return this.orig.width}get height(){return this.orig.height}castToBaseTexture(){return this.baseTexture}static get EMPTY(){return f._EMPTY||(f._EMPTY=new f(new a.BaseTexture),k(f._EMPTY),k(f._EMPTY.baseTexture)),f._EMPTY}static get WHITE(){if(!f._WHITE){const h=
d.settings.ADAPTER.createCanvas(16,16),n=h.getContext("2d");h.width=16;h.height=16;n.fillStyle="white";n.fillRect(0,0,16,16);f._WHITE=new f(a.BaseTexture.from(h));k(f._WHITE);k(f._WHITE.baseTexture)}return f._WHITE}}p.Texture=f}
goog.provide("module$node_modules$$pixi$core$lib$textures$Texture");
goog.global. module$node_modules$$pixi$core$lib$textures$Texture=shadow.js.require(139, {});
