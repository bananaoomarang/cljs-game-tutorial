shadow$provide[314]=function(r,l,A,p){function k(n,q){for(let t=0;t<e.length;t++)if(q.getUint8(t)!==e[t])return console.error(`${n} is not a valid *.ktx file!`),!1;return!0}function m(n){switch(n){case c.FORMATS.RGBA:return c.FORMATS.RGBA_INTEGER;case c.FORMATS.RGB:return c.FORMATS.RGB_INTEGER;case c.FORMATS.RG:return c.FORMATS.RG_INTEGER;case c.FORMATS.RED:return c.FORMATS.RED_INTEGER;default:return n}}function d(n,q,t){const u=new Map;let v=0;for(;v<q;){const z=n.getUint32(64+v,t);var x=64+v+4;
const y=3-(z+3)%4;if(0===z||z>q-v){console.error("KTXLoader: keyAndValueByteSize out of bounds");break}let C=0;for(;C<z&&0!==n.getUint8(x+C);C++);if(-1===C){console.error("KTXLoader: Failed to find null byte terminating kvData key");break}const B=(new TextDecoder).decode(new Uint8Array(n.buffer,x,C));x=new DataView(n.buffer,x+C+1,z-C-1);u.set(B,x);v+=4+z+y}return u}var c=l(209),a=l(307);l(312);var b=l(311);const e=[171,75,84,88,32,49,49,187,13,10,26,10],g={[c.TYPES.UNSIGNED_BYTE]:1,[c.TYPES.UNSIGNED_SHORT]:2,
[c.TYPES.INT]:4,[c.TYPES.UNSIGNED_INT]:4,[c.TYPES.FLOAT]:4,[c.TYPES.HALF_FLOAT]:8},f={[c.FORMATS.RGBA]:4,[c.FORMATS.RGB]:3,[c.FORMATS.RG]:2,[c.FORMATS.RED]:1,[c.FORMATS.LUMINANCE]:1,[c.FORMATS.LUMINANCE_ALPHA]:2,[c.FORMATS.ALPHA]:1},h={[c.TYPES.UNSIGNED_SHORT_4_4_4_4]:2,[c.TYPES.UNSIGNED_SHORT_5_5_5_1]:2,[c.TYPES.UNSIGNED_SHORT_5_6_5]:2};p.FORMATS_TO_COMPONENTS=f;p.TYPES_TO_BYTES_PER_COMPONENT=g;p.TYPES_TO_BYTES_PER_PIXEL=h;p.parseKTX=function(n,q,t=!1){const u=new DataView(q);if(!k(n,u))return null;
n=67305985===u.getUint32(12,!0);const v=u.getUint32(16,n),x=u.getUint32(24,n),z=u.getUint32(28,n),y=u.getUint32(36,n),C=u.getUint32(40,n)||1;var B=u.getUint32(44,n)||1;const w=u.getUint32(48,n)||1;var E=u.getUint32(52,n);const H=u.getUint32(56,n);var I=u.getUint32(60,n);if(0===C||1!==B)throw Error("Only 2D textures are supported");if(1!==E)throw Error("CubeTextures are not supported by KTXLoader yet!");if(1!==w)throw Error("WebGL does not support array textures");var M=y+3&-4,N=C+3&-4;B=Array(w);
E=y*C;0===v&&(E=M*N);let G;if(0!==v?g[v]?G=g[v]*f[x]:G=h[v]:G=a.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[z],void 0===G)throw Error("Unable to resolve the pixel format stored in the *.ktx file!");t=t?d(u,I,n):null;E*=G;let K=y,D=C;I=64+I;for(let F=0;F<H;F++){const J=u.getUint32(I,n);let L=I+4;for(let R=0;R<w;R++){let O=B[R];O||(O=B[R]=Array(H));O[F]={levelID:F,levelWidth:1<H||0!==v?K:M,levelHeight:1<H||0!==v?D:N,levelBuffer:new Uint8Array(q,L,E)};L+=E}I+=J+4;I=0!==I%4?I+4-I%4:I;K=K>>1||1;D=D>>1||1;M=K+4-
1&-4;N=D+4-1&-4;E=M*N*G}return 0!==v?{uncompressed:B.map(F=>{let J=F[0].levelBuffer,L=!1;return v===c.TYPES.FLOAT?J=new Float32Array(F[0].levelBuffer.buffer,F[0].levelBuffer.byteOffset,F[0].levelBuffer.byteLength/4):v===c.TYPES.UNSIGNED_INT?(L=!0,J=new Uint32Array(F[0].levelBuffer.buffer,F[0].levelBuffer.byteOffset,F[0].levelBuffer.byteLength/4)):v===c.TYPES.INT&&(L=!0,J=new Int32Array(F[0].levelBuffer.buffer,F[0].levelBuffer.byteOffset,F[0].levelBuffer.byteLength/4)),{resource:new c.BufferResource(J,
{width:F[0].levelWidth,height:F[0].levelHeight}),type:v,format:L?m(x):x}}),kvData:t}:{compressed:B.map(F=>new b.CompressedTextureResource(null,{format:z,width:y,height:C,levels:H,levelBuffers:F})),kvData:t}}}
goog.provide("module$node_modules$$pixi$compressed_textures$lib$parsers$parseKTX");
goog.global. module$node_modules$$pixi$compressed_textures$lib$parsers$parseKTX=shadow.js.require(314, {});
