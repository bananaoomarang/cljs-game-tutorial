shadow$provide[148]=function(r,l,A,p){var k=l(0);r=l(73);var m=l(8);const d={5126:4,5123:2,5121:1};class c{constructor(a){this.renderer=a;this._activeVao=this._activeGeometry=null;this.hasInstance=this.hasVao=!0;this.canUseUInt32ElementIndex=!1;this.managedGeometries={}}contextChange(){this.disposeAll(!0);const a=this.gl=this.renderer.gl,b=this.renderer.context;if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,2!==b.webGLVersion){let e=this.renderer.context.extensions.vertexArrayObject;m.settings.PREFER_ENV===
k.ENV.WEBGL_LEGACY&&(e=null);e?(a.createVertexArray=()=>e.createVertexArrayOES(),a.bindVertexArray=g=>e.bindVertexArrayOES(g),a.deleteVertexArray=g=>e.deleteVertexArrayOES(g)):(this.hasVao=!1,a.createVertexArray=()=>null,a.bindVertexArray=()=>null,a.deleteVertexArray=()=>null)}if(2!==b.webGLVersion){const e=a.getExtension("ANGLE_instanced_arrays");e?(a.vertexAttribDivisor=(g,f)=>e.vertexAttribDivisorANGLE(g,f),a.drawElementsInstanced=(g,f,h,n,q)=>e.drawElementsInstancedANGLE(g,f,h,n,q),a.drawArraysInstanced=
(g,f,h,n)=>e.drawArraysInstancedANGLE(g,f,h,n)):this.hasInstance=!1}this.canUseUInt32ElementIndex=2===b.webGLVersion||!!b.extensions.uint32ElementIndex}bind(a,b){b=b||this.renderer.shader.shader;const {gl:e}=this;var g=a.glVertexArrayObjects[this.CONTEXT_UID];let f=!1;g||(this.managedGeometries[a.id]=a,a.disposeRunner.add(this),a.glVertexArrayObjects[this.CONTEXT_UID]=g={},f=!0);g=g[b.program.id]||this.initGeometryVao(a,b,f);this._activeGeometry=a;this._activeVao!==g&&(this._activeVao=g,this.hasVao?
e.bindVertexArray(g):this.activateVao(a,b.program));this.updateBuffers()}reset(){this.unbind()}updateBuffers(){const a=this._activeGeometry,b=this.renderer.buffer;for(let e=0;e<a.buffers.length;e++)b.update(a.buffers[e])}checkCompatibility(a,b){a=a.attributes;b=b.attributeData;for(const e in b)if(!a[e])throw Error(`shader and geometry incompatible, geometry missing the "${e}" attribute`);}getSignature(a,b){const e=a.attributes;b=b.attributeData;a=["g",a.id];for(const g in e)b[g]&&a.push(g,b[g].location);
return a.join("-")}initGeometryVao(a,b,e=!0){const g=this.gl,f=this.CONTEXT_UID,h=this.renderer.buffer,n=b.program;n.glPrograms[f]||this.renderer.shader.generateProgram(b);this.checkCompatibility(a,n);b=this.getSignature(a,n);const q=a.glVertexArrayObjects[this.CONTEXT_UID];var t=q[b];if(t)return q[n.id]=t,t;const u=a.buffers;t=a.attributes;var v={};const x={};for(var z in u)v[z]=0,x[z]=0;for(var y in t)!t[y].size&&n.attributeData[y]?t[y].size=n.attributeData[y].size:t[y].size||console.warn(`PIXI Geometry attribute '${y}' size cannot be determined (likely the bound shader does not have the attribute)`),
v[t[y].buffer]+=t[y].size*d[t[y].type];for(var C in t)z=t[C],y=z.size,void 0===z.stride&&(v[z.buffer]===y*d[z.type]?z.stride=0:z.stride=v[z.buffer]),void 0===z.start&&(z.start=x[z.buffer],x[z.buffer]+=y*d[z.type]);t=g.createVertexArray();g.bindVertexArray(t);for(C=0;C<u.length;C++)v=u[C],h.bind(v),e&&v._glBuffers[f].refCount++;return this.activateVao(a,n),q[n.id]=t,q[b]=t,g.bindVertexArray(null),h.unbind(k.BUFFER_TYPE.ARRAY_BUFFER),t}disposeGeometry(a,b){if(this.managedGeometries[a.id]){delete this.managedGeometries[a.id];
var e=a.glVertexArrayObjects[this.CONTEXT_UID],g=this.gl,f=a.buffers,h=this.renderer?.buffer;if(a.disposeRunner.remove(this),e){if(h)for(let n=0;n<f.length;n++){const q=f[n]._glBuffers[this.CONTEXT_UID];q&&(q.refCount--,0===q.refCount&&!b&&h.dispose(f[n],b))}if(!b)for(const n in e)"g"===n[0]&&(b=e[n],this._activeVao===b&&this.unbind(),g.deleteVertexArray(b));delete a.glVertexArrayObjects[this.CONTEXT_UID]}}}disposeAll(a){const b=Object.keys(this.managedGeometries);for(let e=0;e<b.length;e++)this.disposeGeometry(this.managedGeometries[b[e]],
a)}activateVao(a,b){const e=this.gl,g=this.CONTEXT_UID,f=this.renderer.buffer,h=a.buffers,n=a.attributes;a.indexBuffer&&f.bind(a.indexBuffer);a=null;for(const t in n){const u=n[t];var q=h[u.buffer];const v=q._glBuffers[g];if(b.attributeData[t]&&(a!==v&&(f.bind(q),a=v),q=b.attributeData[t].location,e.enableVertexAttribArray(q),e.vertexAttribPointer(q,u.size,u.type||e.FLOAT,u.normalized,u.stride,u.start),u.instance))if(this.hasInstance)e.vertexAttribDivisor(q,u.divisor);else throw Error("geometry error, GPU Instancing is not supported on this device");
}}draw(a,b,e,g){const {gl:f}=this,h=this._activeGeometry;if(h.indexBuffer){const n=h.indexBuffer.data.BYTES_PER_ELEMENT,q=2===n?f.UNSIGNED_SHORT:f.UNSIGNED_INT;2===n||4===n&&this.canUseUInt32ElementIndex?h.instanced?f.drawElementsInstanced(a,b||h.indexBuffer.data.length,q,(e||0)*n,g||1):f.drawElements(a,b||h.indexBuffer.data.length,q,(e||0)*n):console.warn("unsupported index buffer type: uint32")}else h.instanced?f.drawArraysInstanced(a,e,b||h.getSize(),g||1):f.drawArrays(a,e,b||h.getSize());return this}unbind(){this.gl.bindVertexArray(null);
this._activeGeometry=this._activeVao=null}destroy(){this.renderer=null}}c.extension={type:r.ExtensionType.RendererSystem,name:"geometry"};r.extensions.add(c);p.GeometrySystem=c}
goog.provide("module$node_modules$$pixi$core$lib$geometry$GeometrySystem");
goog.global. module$node_modules$$pixi$core$lib$geometry$GeometrySystem=shadow.js.require(148, {});
