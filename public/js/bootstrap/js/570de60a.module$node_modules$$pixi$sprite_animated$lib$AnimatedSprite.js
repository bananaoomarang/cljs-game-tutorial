shadow$provide[371]=function(r,l,A,p){var k=l(209);r=l(216);class m extends r.Sprite{constructor(d,c=!0){super(d[0]instanceof k.Texture?d[0]:d[0].texture);this._durations=this._textures=null;this._autoUpdate=c;this._isConnectedToTicker=!1;this.animationSpeed=1;this.loop=!0;this.updateAnchor=!1;this.onLoop=this.onFrameChange=this.onComplete=null;this._currentTime=0;this._playing=!1;this._previousFrame=null;this.textures=d}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&
(k.Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(k.Ticker.shared.add(this.update,this,k.UPDATE_PRIORITY.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(d){this.stop();this.currentFrame=d}gotoAndPlay(d){this.currentFrame=d;this.play()}update(d){if(this._playing){var c=this.animationSpeed*d,a=this.currentFrame;if(null!==this._durations){let b=this._currentTime%1*this._durations[this.currentFrame];
for(b+=c/60*1E3;0>b;)this._currentTime--,b+=this._durations[this.currentFrame];d=Math.sign(this.animationSpeed*d);for(this._currentTime=Math.floor(this._currentTime);b>=this._durations[this.currentFrame];)b-=this._durations[this.currentFrame]*d,this._currentTime+=d;this._currentTime+=b/this._durations[this.currentFrame]}else this._currentTime+=c;0>this._currentTime&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-
1),this.onComplete&&this.onComplete()):a!==this.currentFrame&&(this.loop&&this.onLoop&&(0<this.animationSpeed&&this.currentFrame<a||0>this.animationSpeed&&this.currentFrame>a)&&this.onLoop(),this.updateTexture())}}updateTexture(){const d=this.currentFrame;this._previousFrame!==d&&(this._previousFrame=d,this._texture=this._textures[d],this._textureID=-1,this._textureTrimmedID=-1,this._cachedTint=16777215,this.uvs=this._texture._uvs.uvsFloat32,this.updateAnchor&&this._anchor.copyFrom(this._texture.defaultAnchor),
this.onFrameChange&&this.onFrameChange(this.currentFrame))}destroy(d){this.stop();super.destroy(d);this.onLoop=this.onFrameChange=this.onComplete=null}static fromFrames(d){const c=[];for(let a=0;a<d.length;++a)c.push(k.Texture.from(d[a]));return new m(c)}static fromImages(d){const c=[];for(let a=0;a<d.length;++a)c.push(k.Texture.from(d[a]));return new m(c)}get totalFrames(){return this._textures.length}get textures(){return this._textures}set textures(d){if(d[0]instanceof k.Texture)this._textures=
d,this._durations=null;else{this._textures=[];this._durations=[];for(let c=0;c<d.length;c++)this._textures.push(d[c].texture),this._durations.push(d[c].time)}this._previousFrame=null;this.gotoAndStop(0);this.updateTexture()}get currentFrame(){let d=Math.floor(this._currentTime)%this._textures.length;return 0>d&&(d+=this._textures.length),d}set currentFrame(d){if(0>d||d>this.totalFrames-1)throw Error(`[AnimatedSprite]: Invalid frame index value ${d}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
const c=this.currentFrame;this._currentTime=d;c!==this.currentFrame&&this.updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(d){d!==this._autoUpdate&&(this._autoUpdate=d,!this._autoUpdate&&this._isConnectedToTicker?(k.Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(k.Ticker.shared.add(this.update,this),this._isConnectedToTicker=!0))}}p.AnimatedSprite=m}
goog.provide("module$node_modules$$pixi$sprite_animated$lib$AnimatedSprite");
goog.global. module$node_modules$$pixi$sprite_animated$lib$AnimatedSprite=shadow.js.require(371, {});
