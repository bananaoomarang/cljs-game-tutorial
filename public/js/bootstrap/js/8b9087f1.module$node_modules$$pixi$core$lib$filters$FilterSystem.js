shadow$provide[145]=function(r,l,A,p){var k=l(0);r=l(73);var m=l(102),d=l(141),c=l(118),a=l(142),b=l(143),e=l(144);const g=[new m.Point,new m.Point,new m.Point,new m.Point],f=new m.Matrix;class h{constructor(n){this.renderer=n;this.defaultFilterStack=[{}];this.texturePool=new d.RenderTexturePool;this.statePool=[];this.quad=new a.Quad;this.quadUv=new b.QuadUv;this.tempRect=new m.Rectangle;this.activeState={};this.globalUniforms=new c.UniformGroup({outputFrame:new m.Rectangle,inputSize:new Float32Array(4),
inputPixel:new Float32Array(4),inputClamp:new Float32Array(4),resolution:1,filterArea:new Float32Array(4),filterClamp:new Float32Array(4)},!0);this.useMaxPadding=this.forceClear=!1}init(){this.texturePool.setScreenSize(this.renderer.view)}push(n,q){const t=this.renderer,u=this.defaultFilterStack,v=this.statePool.pop()||new e.FilterState,x=t.renderTexture;let z,y;if(x.current){var C=x.current;z=C.resolution;y=C.multisample}else z=t.resolution,y=t.multisample;C=q[0].resolution||z;let B=q[0].multisample??
y,w=q[0].padding,E=q[0].autoFit,H=q[0].legacy??!0;for(let I=1;I<q.length;I++){const M=q[I];C=Math.min(C,M.resolution||z);B=Math.min(B,M.multisample??y);w=this.useMaxPadding?Math.max(w,M.padding):w+M.padding;E=E&&M.autoFit;H=H||(M.legacy??!0)}1===u.length&&(this.defaultFilterStack[0].renderTexture=x.current);u.push(v);v.resolution=C;v.multisample=B;v.legacy=H;v.target=n;v.sourceFrame.copyFrom(n.filterArea||n.getBounds(!0));v.sourceFrame.pad(w);n=this.tempRect.copyFrom(x.sourceFrame);t.projection.transform&&
this.transformAABB(f.copyFrom(t.projection.transform).invert(),n);E?(v.sourceFrame.fit(n),(0>=v.sourceFrame.width||0>=v.sourceFrame.height)&&(v.sourceFrame.width=0,v.sourceFrame.height=0)):v.sourceFrame.intersects(n)||(v.sourceFrame.width=0,v.sourceFrame.height=0);this.roundFrame(v.sourceFrame,x.current?x.current.resolution:t.resolution,x.sourceFrame,x.destinationFrame,t.projection.transform);v.renderTexture=this.getOptimalFilterTexture(v.sourceFrame.width,v.sourceFrame.height,C,B);v.filters=q;v.destinationFrame.width=
v.renderTexture.width;v.destinationFrame.height=v.renderTexture.height;q=this.tempRect;q.x=0;q.y=0;q.width=v.sourceFrame.width;q.height=v.sourceFrame.height;v.renderTexture.filterFrame=v.sourceFrame;v.bindingSourceFrame.copyFrom(x.sourceFrame);v.bindingDestinationFrame.copyFrom(x.destinationFrame);v.transform=t.projection.transform;t.projection.transform=null;x.bind(v.renderTexture,v.sourceFrame,q);t.framebuffer.clear(0,0,0,0)}pop(){var n=this.defaultFilterStack;const q=n.pop(),t=q.filters;this.activeState=
q;var u=this.globalUniforms.uniforms;u.outputFrame=q.sourceFrame;u.resolution=q.resolution;var v=u.inputSize,x=u.inputPixel,z=u.inputClamp;if(v[0]=q.destinationFrame.width,v[1]=q.destinationFrame.height,v[2]=1/v[0],v[3]=1/v[1],x[0]=Math.round(v[0]*q.resolution),x[1]=Math.round(v[1]*q.resolution),x[2]=1/x[0],x[3]=1/x[1],z[0]=.5*x[2],z[1]=.5*x[3],z[2]=q.sourceFrame.width*v[2]-.5*x[2],z[3]=q.sourceFrame.height*v[3]-.5*x[3],q.legacy)v=u.filterArea,v[0]=q.destinationFrame.width,v[1]=q.destinationFrame.height,
v[2]=q.sourceFrame.x,v[3]=q.sourceFrame.y,u.filterClamp=u.inputClamp;this.globalUniforms.update();n=n[n.length-1];if(this.renderer.framebuffer.blit(),1===t.length)t[0].apply(this,q.renderTexture,n.renderTexture,k.CLEAR_MODES.BLEND,q),this.returnFilterTexture(q.renderTexture);else{u=q.renderTexture;v=this.getOptimalFilterTexture(u.width,u.height,q.resolution);v.filterFrame=u.filterFrame;for(x=0;x<t.length-1;++x)1===x&&1<q.multisample&&(v=this.getOptimalFilterTexture(u.width,u.height,q.resolution),
v.filterFrame=u.filterFrame),t[x].apply(this,u,v,k.CLEAR_MODES.CLEAR,q),z=u,u=v,v=z;t[x].apply(this,u,n.renderTexture,k.CLEAR_MODES.BLEND,q);1<x&&1<q.multisample&&this.returnFilterTexture(q.renderTexture);this.returnFilterTexture(u);this.returnFilterTexture(v)}q.clear();this.statePool.push(q)}bindAndClear(n,q=k.CLEAR_MODES.CLEAR){const {renderTexture:t,state:u}=this.renderer;if(n===this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?this.renderer.projection.transform=this.activeState.transform:
this.renderer.projection.transform=null,n?.filterFrame){const v=this.tempRect;v.x=0;v.y=0;v.width=n.filterFrame.width;v.height=n.filterFrame.height;t.bind(n,n.filterFrame,v)}else n!==this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?t.bind(n):this.renderer.renderTexture.bind(n,this.activeState.bindingSourceFrame,this.activeState.bindingDestinationFrame);n=u.stateId&1||this.forceClear;(q===k.CLEAR_MODES.CLEAR||q===k.CLEAR_MODES.BLIT&&n)&&this.renderer.framebuffer.clear(0,0,0,
0)}applyFilter(n,q,t,u){const v=this.renderer;v.state.set(n.state);this.bindAndClear(t,u);n.uniforms.uSampler=q;n.uniforms.filterGlobals=this.globalUniforms;v.shader.bind(n);n.legacy=!!n.program.attributeData.aTextureCoord;n.legacy?(this.quadUv.map(q._frame,q.filterFrame),v.geometry.bind(this.quadUv),v.geometry.draw(k.DRAW_MODES.TRIANGLES)):(v.geometry.bind(this.quad),v.geometry.draw(k.DRAW_MODES.TRIANGLE_STRIP))}calculateSpriteMatrix(n,q){const {sourceFrame:t,destinationFrame:u}=this.activeState,
{orig:v}=q._texture;n=n.set(u.width,0,0,u.height,t.x,t.y);const x=q.worldTransform.copyTo(m.Matrix.TEMP_MATRIX);return x.invert(),n.prepend(x),n.scale(1/v.width,1/v.height),n.translate(q.anchor.x,q.anchor.y),n}destroy(){this.renderer=null;this.texturePool.clear(!1)}getOptimalFilterTexture(n,q,t=1,u=k.MSAA_QUALITY.NONE){return this.texturePool.getOptimalTexture(n,q,t,u)}getFilterTexture(n,q,t){if("number"==typeof n){const u=n;n=q;q=u}n=n||this.activeState.renderTexture;q=this.texturePool.getOptimalTexture(n.width,
n.height,q||n.resolution,t||k.MSAA_QUALITY.NONE);return q.filterFrame=n.filterFrame,q}returnFilterTexture(n){this.texturePool.returnTexture(n)}emptyPool(){this.texturePool.clear(!0)}resize(){this.texturePool.setScreenSize(this.renderer.view)}transformAABB(n,q){var t=g[0];const u=g[1],v=g[2],x=g[3];t.set(q.left,q.top);u.set(q.left,q.bottom);v.set(q.right,q.top);x.set(q.right,q.bottom);n.apply(t,t);n.apply(u,u);n.apply(v,v);n.apply(x,x);n=Math.min(t.x,u.x,v.x,x.x);const z=Math.min(t.y,u.y,v.y,x.y),
y=Math.max(t.x,u.x,v.x,x.x);t=Math.max(t.y,u.y,v.y,x.y);q.x=n;q.y=z;q.width=y-n;q.height=t-z}roundFrame(n,q,t,u,v){if(!(0>=n.width||0>=n.height||0>=t.width||0>=t.height)){if(v){const {a:x,b:z,c:y,d:C}=v;if((1E-4<Math.abs(z)||1E-4<Math.abs(y))&&(1E-4<Math.abs(x)||1E-4<Math.abs(C)))return}v=v?f.copyFrom(v):f.identity();v.translate(-t.x,-t.y).scale(u.width/t.width,u.height/t.height).translate(u.x,u.y);this.transformAABB(v,n);n.ceil(q);this.transformAABB(v.invert(),n)}}}h.extension={type:r.ExtensionType.RendererSystem,
name:"filter"};r.extensions.add(h);p.FilterSystem=h}
goog.provide("module$node_modules$$pixi$core$lib$filters$FilterSystem");
goog.global. module$node_modules$$pixi$core$lib$filters$FilterSystem=shadow.js.require(145, {});
