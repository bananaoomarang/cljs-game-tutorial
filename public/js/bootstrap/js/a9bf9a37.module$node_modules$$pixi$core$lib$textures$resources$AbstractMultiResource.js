shadow$provide[199]=function(r,l,A,p){var k=l(82),m=l(77),d=l(80);class c extends d.Resource{constructor(a,b){const {width:e,height:g}=b||{};super(e,g);this.items=[];this.itemDirtyIds=[];for(b=0;b<a;b++){const f=new k.BaseTexture;this.items.push(f);this.itemDirtyIds.push(-2)}this.length=a;this.baseTexture=this._load=null}initFromArray(a,b){for(let e=0;e<this.length;e++)a[e]&&(a[e].castToBaseTexture?this.addBaseTextureAt(a[e].castToBaseTexture(),e):a[e]instanceof d.Resource?this.addResourceAt(a[e],
e):this.addResourceAt(m.autoDetectResource(a[e],b),e))}dispose(){for(let a=0,b=this.length;a<b;a++)this.items[a].destroy();this._load=this.itemDirtyIds=this.items=null}addResourceAt(a,b){if(!this.items[b])throw Error(`Index ${b} is out of bounds`);return a.valid&&!this.valid&&this.resize(a.width,a.height),this.items[b].setResource(a),this}bind(a){if(null!==this.baseTexture)throw Error("Only one base texture per TextureArray is allowed");super.bind(a);for(let b=0;b<this.length;b++)this.items[b].parentTextureArray=
a,this.items[b].on("update",a.update,a)}unbind(a){super.unbind(a);for(let b=0;b<this.length;b++)this.items[b].parentTextureArray=null,this.items[b].off("update",a.update,a)}load(){if(this._load)return this._load;const a=this.items.map(b=>b.resource).filter(b=>b).map(b=>b.load());return this._load=Promise.all(a).then(()=>{const {realWidth:b,realHeight:e}=this.items[0];return this.resize(b,e),this.update(),Promise.resolve(this)}),this._load}}p.AbstractMultiResource=c}
goog.provide("module$node_modules$$pixi$core$lib$textures$resources$AbstractMultiResource");
goog.global. module$node_modules$$pixi$core$lib$textures$resources$AbstractMultiResource=shadow.js.require(199, {});
