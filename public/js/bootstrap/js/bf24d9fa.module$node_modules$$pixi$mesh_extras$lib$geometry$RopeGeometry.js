shadow$provide[348]=function(r,l,A,p){r=l(346);class k extends r.MeshGeometry{constructor(m=200,d,c=0){super(new Float32Array(4*d.length),new Float32Array(4*d.length),new Uint16Array(6*(d.length-1)));this.points=d;this._width=m;this.textureScale=c;this.build()}get width(){return this._width}build(){var m=this.points;if(m){var d=this.getBuffer("aVertexPosition"),c=this.getBuffer("aTextureCoord"),a=this.getIndex();if(!(1>m.length)){d.data.length/4!==m.length&&(d.data=new Float32Array(4*m.length),c.data=
new Float32Array(4*m.length),a.data=new Uint16Array(6*(m.length-1)));var b=c.data;d=a.data;b[0]=0;b[1]=0;b[2]=0;b[3]=1;var e=0,g=m[0],f=this._width*this.textureScale,h=m.length;for(let q=0;q<h;q++){const t=4*q;if(0<this.textureScale){var n=g.x-m[q].x;g=g.y-m[q].y;n=Math.sqrt(n*n+g*g);g=m[q];e+=n/f}else e=q/(h-1);b[t]=e;b[t+1]=0;b[t+2]=e;b[t+3]=1}m=0;for(b=0;b<h-1;b++)e=2*b,d[m++]=e,d[m++]=e+1,d[m++]=e+2,d[m++]=e+2,d[m++]=e+1,d[m++]=e+3;c.update();a.update();this.updateVertices()}}}updateVertices(){const m=
this.points;if(!(1>m.length)){var d=m[0],c,a=this.buffers[0].data,b=m.length,e=0<this.textureScale?this.textureScale*this._width/2:this._width/2;for(let f=0;f<b;f++){const h=m[f],n=4*f;f<m.length-1?c=m[f+1]:c=h;var g=-(c.x-d.x);d=c.y-d.y;const q=Math.sqrt(d*d+g*g);1E-6>q?(d=0,g=0):(d/=q,g/=q,d*=e,g*=e);a[n]=h.x+d;a[n+1]=h.y+g;a[n+2]=h.x-d;a[n+3]=h.y-g;d=h}this.buffers[0].update()}}update(){0<this.textureScale?this.build():this.updateVertices()}}p.RopeGeometry=k}
goog.provide("module$node_modules$$pixi$mesh_extras$lib$geometry$RopeGeometry");
goog.global. module$node_modules$$pixi$mesh_extras$lib$geometry$RopeGeometry=shadow.js.require(348, {});
