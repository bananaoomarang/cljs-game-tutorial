shadow$provide[127]=function(r,l,A,p){var k=l(52),m=l(0);r=l(73);var d=l(8),c=l(72),a=l(74),b=l(75),e=l(76),g=l(82),f=l(83),h=l(88),n=l(120),q=l(121),t=l(122),u=l(123);A=l(124);var v=l(125),x=l(126);const z=class extends A.ObjectRenderer{constructor(y){super(y);this.setShaderGenerator();this.geometryClass=h.BatchGeometry;this.vertexSize=6;this.state=e.State.for2d();this.size=4*z.defaultBatchSize;this._indexCount=this._vertexCount=0;this._bufferedElements=[];this._bufferedTextures=[];this._bufferSize=
0;this._shader=null;this._packedGeometries=[];this._packedGeometryPoolSize=2;this._flushId=0;this._aBuffers={};this._iBuffers={};this.maxTextures=1;this.renderer.on("prerender",this.onPrerender,this);y.runners.contextChange.add(this);this._iIndex=this._aIndex=this._dcIndex=0;this._indexBuffer=this._attributeBuffer=null;this._tempBoundTextures=[]}static get defaultMaxTextures(){return this._defaultMaxTextures=this._defaultMaxTextures??u.maxRecommendedTextures(32),this._defaultMaxTextures}static set defaultMaxTextures(y){this._defaultMaxTextures=
y}static get canUploadSameBuffer(){return this._canUploadSameBuffer=this._canUploadSameBuffer??t.canUploadSameBuffer(),this._canUploadSameBuffer}static set canUploadSameBuffer(y){this._canUploadSameBuffer=y}get MAX_TEXTURES(){return c.deprecation("7.1.0","BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),this.maxTextures}static get defaultVertexSrc(){return x.default}static get defaultFragmentTemplate(){return v.default}setShaderGenerator({vertex:y=z.defaultVertexSrc,fragment:C=z.defaultFragmentTemplate}=
{}){this.shaderGenerator=new n.BatchShaderGenerator(y,C)}contextChange(){var y=this.renderer.gl;d.settings.PREFER_ENV===m.ENV.WEBGL_LEGACY?this.maxTextures=1:(this.maxTextures=Math.min(y.getParameter(y.MAX_TEXTURE_IMAGE_UNITS),z.defaultMaxTextures),this.maxTextures=b.checkMaxIfStatementsInShader(this.maxTextures,y));this._shader=this.shaderGenerator.generateShader(this.maxTextures);for(y=0;y<this._packedGeometryPoolSize;y++)this._packedGeometries[y]=new this.geometryClass;this.initFlushBuffers()}initFlushBuffers(){const {_drawCallPool:y,
_textureArrayPool:C}=z;var B=this.size/4;const w=Math.floor(B/this.maxTextures)+1;for(;y.length<B;)y.push(new f.BatchDrawCall);for(;C.length<w;)C.push(new q.BatchTextureArray);for(B=0;B<this.maxTextures;B++)this._tempBoundTextures[B]=null}onPrerender(){this._flushId=0}render(y){y._texture.valid&&(this._vertexCount+y.vertexData.length/2>this.size&&this.flush(),this._vertexCount+=y.vertexData.length/2,this._indexCount+=y.indices.length,this._bufferedTextures[this._bufferSize]=y._texture.baseTexture,
this._bufferedElements[this._bufferSize++]=y)}buildTexturesAndDrawCalls(){const {_bufferedTextures:y,maxTextures:C}=this;var B=z._textureArrayPool;const w=this.renderer.batch,E=this._tempBoundTextures,H=this.renderer.textureGC.count;let I=++g.BaseTexture._globalBatch,M=0,N=B[0],G=0;w.copyBoundTextures(E,C);for(let K=0;K<this._bufferSize;++K){const D=y[K];y[K]=null;D._batchEnabled!==I&&(N.count>=C&&(w.boundArray(N,E,I,C),this.buildDrawCalls(N,G,K),G=K,N=B[++M],++I),D._batchEnabled=I,D.touched=H,N.elements[N.count++]=
D)}0<N.count&&(w.boundArray(N,E,I,C),this.buildDrawCalls(N,G,this._bufferSize),++M,++I);for(B=0;B<E.length;B++)E[B]=null;g.BaseTexture._globalBatch=I}buildDrawCalls(y,C,B){const {_bufferedElements:w,_attributeBuffer:E,_indexBuffer:H,vertexSize:I}=this,M=z._drawCallPool;let N=this._dcIndex,G=this._aIndex,K=this._iIndex,D=M[N];D.start=this._iIndex;D.texArray=y;for(let F=C;F<B;++F){const J=w[F],L=c.premultiplyBlendMode[J._texture.baseTexture.alphaMode?1:0][J.blendMode];w[F]=null;C<F&&D.blend!==L&&(D.size=
K-D.start,C=F,D=M[++N],D.texArray=y,D.start=K);this.packInterleavedGeometry(J,E,H,G,K);G+=J.vertexData.length/2*I;K+=J.indices.length;D.blend=L}C<B&&(D.size=K-D.start,++N);this._dcIndex=N;this._aIndex=G;this._iIndex=K}bindAndClearTexArray(y){const C=this.renderer.texture;for(let B=0;B<y.count;B++)C.bind(y.elements[B],y.ids[B]),y.elements[B]=null;y.count=0}updateGeometry(){const {_packedGeometries:y,_attributeBuffer:C,_indexBuffer:B}=this;z.canUploadSameBuffer?(y[this._flushId]._buffer.update(C.rawBinaryData),
y[this._flushId]._indexBuffer.update(B),this.renderer.geometry.updateBuffers()):(this._packedGeometryPoolSize<=this._flushId&&(this._packedGeometryPoolSize++,y[this._flushId]=new this.geometryClass),y[this._flushId]._buffer.update(C.rawBinaryData),y[this._flushId]._indexBuffer.update(B),this.renderer.geometry.bind(y[this._flushId]),this.renderer.geometry.updateBuffers(),this._flushId++)}drawBatches(){const y=this._dcIndex,{gl:C,state:B}=this.renderer,w=z._drawCallPool;let E=null;for(let H=0;H<y;H++){const {texArray:I,
type:M,size:N,start:G,blend:K}=w[H];E!==I&&(E=I,this.bindAndClearTexArray(I));this.state.blendMode=K;B.set(this.state);C.drawElements(M,N,C.UNSIGNED_SHORT,2*G)}}flush(){0!==this._vertexCount&&(this._attributeBuffer=this.getAttributeBuffer(this._vertexCount),this._indexBuffer=this.getIndexBuffer(this._indexCount),this._aIndex=0,this._iIndex=0,this._dcIndex=0,this.buildTexturesAndDrawCalls(),this.updateGeometry(),this.drawBatches(),this._bufferSize=0,this._vertexCount=0,this._indexCount=0)}start(){this.renderer.state.set(this.state);
this.renderer.texture.ensureSamplerType(this.maxTextures);this.renderer.shader.bind(this._shader);z.canUploadSameBuffer&&this.renderer.geometry.bind(this._packedGeometries[this._flushId])}stop(){this.flush()}destroy(){for(let y=0;y<this._packedGeometryPoolSize;y++)this._packedGeometries[y]&&this._packedGeometries[y].destroy();this.renderer.off("prerender",this.onPrerender,this);this._indexBuffer=this._attributeBuffer=this._packedGeometries=this._iBuffers=this._aBuffers=null;this._shader&&(this._shader.destroy(),
this._shader=null);super.destroy()}getAttributeBuffer(y){var C=c.nextPow2(Math.ceil(y/8));y=c.log2(C);C*=8;this._aBuffers.length<=y&&(this._iBuffers.length=y+1);y=this._aBuffers[C];return y||(this._aBuffers[C]=y=new a.ViewableBuffer(C*this.vertexSize*4)),y}getIndexBuffer(y){y=c.nextPow2(Math.ceil(y/12));const C=c.log2(y);this._iBuffers.length<=C&&(this._iBuffers.length=C+1);let B=this._iBuffers[C];return B||(this._iBuffers[C]=B=new Uint16Array(12*y)),B}packInterleavedGeometry(y,C,B,w,E){const {uint32View:H,
float32View:I}=C;C=w/this.vertexSize;const M=y.uvs,N=y.indices,G=y.vertexData,K=y._texture.baseTexture._batchLocation;var D=Math.min(y.worldAlpha,1);y=k.Color.shared.setValue(y._tintRGB).toPremultiplied(D,0<y._texture.baseTexture.alphaMode);for(D=0;D<G.length;D+=2)I[w++]=G[D],I[w++]=G[D+1],I[w++]=M[D],I[w++]=M[D+1],H[w++]=y,I[w++]=K;for(w=0;w<N.length;w++)B[E++]=C+N[w]}};l=z;l.defaultBatchSize=4096;l.extension={name:"batch",type:r.ExtensionType.RendererPlugin};l._drawCallPool=[];l._textureArrayPool=
[];r.extensions.add(l);p.BatchRenderer=l}
goog.provide("module$node_modules$$pixi$core$lib$batch$BatchRenderer");
goog.global. module$node_modules$$pixi$core$lib$batch$BatchRenderer=shadow.js.require(127, {});
