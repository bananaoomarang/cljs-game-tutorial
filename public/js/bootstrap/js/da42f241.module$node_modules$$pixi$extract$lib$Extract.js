shadow$provide[321]=function(r,l,A,p){var k=l(209);const m=new k.Rectangle;r=(()=>{const d=class{constructor(c){this.renderer=c;this._rendererPremultipliedAlpha=!1}contextChange(){const c=this.renderer?.gl.getContextAttributes();this._rendererPremultipliedAlpha=!!(c&&c.alpha&&c.premultipliedAlpha)}async image(c,a,b,e){const g=new Image;return g.src=await this.base64(c,a,b,e),g}async base64(c,a,b,e){const g=this.canvas(c,e);if(void 0!==g.toBlob)return new Promise((f,h)=>{g.toBlob(n=>{if(n){var q=new FileReader;
q.onload=()=>f(q.result);q.onerror=h;q.readAsDataURL(n)}else h(Error("ICanvas.toBlob failed!"))},a,b)});if(void 0!==g.toDataURL)return g.toDataURL(a,b);if(void 0!==g.convertToBlob){const f=await g.convertToBlob({type:a,quality:b});return new Promise((h,n)=>{const q=new FileReader;q.onload=()=>h(q.result);q.onerror=n;q.readAsDataURL(f)})}throw Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");}canvas(c,a){const {pixels:b,width:e,height:g,
flipY:f,premultipliedAlpha:h}=this._rawPixels(c,a);f&&d._flipY(b,e,g);h&&d._unpremultiplyAlpha(b);c=new k.utils.CanvasRenderTarget(e,g,1);a=new ImageData(new Uint8ClampedArray(b.buffer),e,g);return c.context.putImageData(a,0,0),c.canvas}pixels(c,a){const {pixels:b,width:e,height:g,flipY:f,premultipliedAlpha:h}=this._rawPixels(c,a);return f&&d._flipY(b,e,g),h&&d._unpremultiplyAlpha(b),b}_rawPixels(c,a){var b=this.renderer;if(!b)throw Error("The Extract has already been destroyed");let e,g,f,h=!1;c&&
(c instanceof k.RenderTexture?f=c:(f=b.generateTexture(c,{region:a,resolution:b.resolution,multisample:b.multisample}),h=!0,a&&(m.width=a.width,m.height=a.height,a=m)));const n=b.gl;if(f){if(c=f.baseTexture.resolution,a=a??f.frame,e=!1,g=0<f.baseTexture.alphaMode&&f.baseTexture.format===k.FORMATS.RGBA,!h){b.renderTexture.bind(f);var q=f.framebuffer.glFramebuffers[b.CONTEXT_UID];q.blitFramebuffer&&b.framebuffer.bind(q.blitFramebuffer)}}else c=b.resolution,a||(a=m,a.width=b.width/c,a.height=b.height/
c),e=!0,g=this._rendererPremultipliedAlpha,b.renderTexture.bind();b=Math.max(Math.round(a.width*c),1);q=Math.max(Math.round(a.height*c),1);const t=new Uint8Array(4*b*q);return n.readPixels(Math.round(a.x*c),Math.round(a.y*c),b,q,n.RGBA,n.UNSIGNED_BYTE,t),h&&f?.destroy(!0),{pixels:t,width:b,height:q,flipY:e,premultipliedAlpha:g}}destroy(){this.renderer=null}static _flipY(c,a,b){a<<=2;const e=b>>1,g=new Uint8Array(a);for(let f=0;f<e;f++){const h=f*a,n=(b-f-1)*a;g.set(c.subarray(h,h+a));c.copyWithin(h,
n,n+a);c.set(g,n)}}static _unpremultiplyAlpha(c){c instanceof Uint8ClampedArray&&(c=new Uint8Array(c.buffer));const a=c.length;for(let e=0;e<a;e+=4){var b=c[e+3];0!==b&&(b=255.001/b,c[e]=c[e]*b+.5,c[e+1]=c[e+1]*b+.5,c[e+2]=c[e+2]*b+.5)}}};return d})();r.extension={name:"extract",type:k.ExtensionType.RendererSystem};k.extensions.add(r);p.Extract=r}
goog.provide("module$node_modules$$pixi$extract$lib$Extract");
goog.global. module$node_modules$$pixi$extract$lib$Extract=shadow.js.require(321, {});
