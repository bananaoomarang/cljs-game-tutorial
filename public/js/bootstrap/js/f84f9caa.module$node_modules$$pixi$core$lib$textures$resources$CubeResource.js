shadow$provide[202]=function(r,l,A,p){var k=l(0);r=l(199);const m=class extends r.AbstractMultiResource{constructor(d,c){const {width:a,height:b,autoLoad:e,linkBaseTexture:g}=c||{};if(d&&d.length!==m.SIDES)throw Error(`Invalid length. Got ${d.length}, expected 6`);super(6,{width:a,height:b});for(let f=0;f<m.SIDES;f++)this.items[f].target=k.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+f;this.linkBaseTexture=!1!==g;d&&this.initFromArray(d,c);!1!==e&&this.load()}bind(d){super.bind(d);d.target=k.TARGETS.TEXTURE_CUBE_MAP}addBaseTextureAt(d,
c,a){if(!this.items[c])throw Error(`Index ${c} is out of bounds`);if(!this.linkBaseTexture||d.parentTextureArray||0<Object.keys(d._glTextures).length)if(d.resource)this.addResourceAt(d.resource,c);else throw Error("CubeResource does not support copying of renderTexture.");else d.target=k.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+c,d.parentTextureArray=this.baseTexture,this.items[c]=d;return d.valid&&!this.valid&&this.resize(d.realWidth,d.realHeight),this.items[c]=d,this}upload(d,c,a){const b=this.itemDirtyIds;
for(let e=0;e<m.SIDES;e++){const g=this.items[e];(b[e]<g.dirtyId||a.dirtyId<c.dirtyId)&&(g.valid&&g.resource?(g.resource.upload(d,g,a),b[e]=g.dirtyId):-1>b[e]&&(d.gl.texImage2D(g.target,0,a.internalFormat,c.realWidth,c.realHeight,0,c.format,a.type,null),b[e]=-1))}return!0}static test(d){return Array.isArray(d)&&d.length===m.SIDES}};r=m;r.SIDES=6;p.CubeResource=r}
goog.provide("module$node_modules$$pixi$core$lib$textures$resources$CubeResource");
goog.global. module$node_modules$$pixi$core$lib$textures$resources$CubeResource=shadow.js.require(202, {});
