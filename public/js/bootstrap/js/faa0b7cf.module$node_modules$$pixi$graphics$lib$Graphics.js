shadow$provide[338]=function(r,l,A,p){var k=l(209),m=l(214),d=l(327),c=l(335),a=l(336),b=l(337);l(333);var e=l(332),g=l(330),f=l(328);const h={};r=(()=>{const n=class extends m.Container{constructor(q=null){super();this.shader=null;this.pluginName="batch";this.currentPath=null;this.batches=[];this.batchDirty=this.batchTint=-1;this.vertexData=null;this._fillStyle=new a.FillStyle;this._lineStyle=new b.LineStyle;this._matrix=null;this._holeMode=!1;this.state=k.State.for2d();this._geometry=q||new c.GraphicsGeometry;
this._geometry.refCount++;this._transformID=-1;this._tintColor=new k.Color(16777215);this.blendMode=k.BLEND_MODES.NORMAL}get geometry(){return this._geometry}clone(){return this.finishPoly(),new n(this._geometry)}set blendMode(q){this.state.blendMode=q}get blendMode(){return this.state.blendMode}get tint(){return this._tintColor.value}set tint(q){this._tintColor.setValue(q)}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(q=null,t=0,u,v=.5,x=!1){return"number"==typeof q&&
(q={width:q,color:t,alpha:u,alignment:v,native:x}),this.lineTextureStyle(q)}lineTextureStyle(q){q=Object.assign({width:0,texture:k.Texture.WHITE,color:q?.texture?16777215:0,matrix:null,alignment:.5,native:!1,cap:d.LINE_CAP.BUTT,join:d.LINE_JOIN.MITER,miterLimit:10},q);this.normalizeColor(q);this.currentPath&&this.startPoly();const t=0<q.width&&0<q.alpha;return t?(q.matrix&&(q.matrix=q.matrix.clone(),q.matrix.invert()),Object.assign(this._lineStyle,{visible:t},q)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const q=
this.currentPath.points,t=this.currentPath.points.length;2<t&&(this.drawShape(this.currentPath),this.currentPath=new k.Polygon,this.currentPath.closeStroke=!1,this.currentPath.points.push(q[t-2],q[t-1]))}else this.currentPath=new k.Polygon,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(2<this.currentPath.points.length?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(q,t){return this.startPoly(),this.currentPath.points[0]=q,this.currentPath.points[1]=
t,this}lineTo(q,t){this.currentPath||this.moveTo(0,0);const u=this.currentPath.points,v=u[u.length-1];return(u[u.length-2]!==q||v!==t)&&u.push(q,t),this}_initCurve(q=0,t=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[q,t]):this.moveTo(q,t)}quadraticCurveTo(q,t,u,v){this._initCurve();const x=this.currentPath.points;return 0===x.length&&this.moveTo(0,0),e.QuadraticUtils.curveTo(q,t,u,v,x),this}bezierCurveTo(q,t,u,v,x,z){return this._initCurve(),g.BezierUtils.curveTo(q,
t,u,v,x,z,this.currentPath.points),this}arcTo(q,t,u,v,x){this._initCurve(q,t);if(q=f.ArcUtils.curveTo(q,t,u,v,x,this.currentPath.points)){const {cx:z,cy:y,radius:C,startAngle:B,endAngle:w,anticlockwise:E}=q;this.arc(z,y,C,B,w,E)}return this}arc(q,t,u,v,x,z=!1){if(v===x||(!z&&x<=v?x+=k.PI_2:z&&v<=x&&(v+=k.PI_2),0===x-v))return this;const y=q+Math.cos(v)*u,C=t+Math.sin(v)*u,B=this._geometry.closePointEps;let w=this.currentPath?this.currentPath.points:null;if(w){const E=Math.abs(w[w.length-1]-C);Math.abs(w[w.length-
2]-y)<B&&E<B||w.push(y,C)}else this.moveTo(y,C),w=this.currentPath.points;return f.ArcUtils.arc(y,C,q,t,u,v,x,z,w),this}beginFill(q=0,t){return this.beginTextureFill({texture:k.Texture.WHITE,color:q,alpha:t})}normalizeColor(q){const t=k.Color.shared.setValue(q.color??0);q.color=t.toNumber();q.alpha??(q.alpha=t.alpha)}beginTextureFill(q){q=Object.assign({texture:k.Texture.WHITE,color:16777215,matrix:null},q);this.normalizeColor(q);this.currentPath&&this.startPoly();const t=0<q.alpha;return t?(q.matrix&&
(q.matrix=q.matrix.clone(),q.matrix.invert()),Object.assign(this._fillStyle,{visible:t},q)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(q,t,u,v){return this.drawShape(new k.Rectangle(q,t,u,v))}drawRoundedRect(q,t,u,v,x){return this.drawShape(new k.RoundedRectangle(q,t,u,v,x))}drawCircle(q,t,u){return this.drawShape(new k.Circle(q,t,u))}drawEllipse(q,t,u,v){return this.drawShape(new k.Ellipse(q,t,u,v))}drawPolygon(...q){let t,u=!0;const v=q[0];
v.points?(u=v.closeStroke,t=v.points):Array.isArray(q[0])?t=q[0]:t=q;q=new k.Polygon(t);return q.closeStroke=u,this.drawShape(q),this}drawShape(q){return this._holeMode?this._geometry.drawHole(q,this._matrix):this._geometry.drawShape(q,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const q=this._geometry.graphicsData;
return 1===q.length&&q[0].shape.type===k.SHAPES.RECT&&!q[0].matrix&&!q[0].holes.length&&!(q[0].lineStyle.visible&&q[0].lineStyle.width)}_render(q){this.finishPoly();const t=this._geometry;t.updateBatches();t.batchable?(this.batchDirty!==t.batchDirty&&this._populateBatches(),this._renderBatched(q)):(q.batch.flush(),this._renderDirect(q))}_populateBatches(){const q=this._geometry,t=this.blendMode,u=q.batches.length;this._transformID=this.batchTint=-1;this.batchDirty=q.batchDirty;this.batches.length=
u;this.vertexData=new Float32Array(q.points);for(let x=0;x<u;x++){var v=q.batches[x];const z=v.style.color,y=new Float32Array(this.vertexData.buffer,8*v.attribStart,2*v.attribSize),C=new Float32Array(q.uvsFloat32.buffer,8*v.attribStart,2*v.attribSize),B=new Uint16Array(q.indicesUint16.buffer,2*v.start,v.size);v={vertexData:y,blendMode:t,indices:B,uvs:C,_batchRGB:k.Color.shared.setValue(z).toRgbArray(),_tintRGB:z,_texture:v.style.texture,alpha:v.style.alpha,worldAlpha:1};this.batches[x]=v}}_renderBatched(q){if(this.batches.length){q.batch.setObjectRenderer(q.plugins[this.pluginName]);
this.calculateVertices();this.calculateTints();for(let t=0,u=this.batches.length;t<u;t++){const v=this.batches[t];v.worldAlpha=this.worldAlpha*v.alpha;q.plugins[this.pluginName].render(v)}}}_renderDirect(q){const t=this._resolveDirectShader(q),u=this._geometry,v=this.worldAlpha,x=t.uniforms,z=u.drawCalls;x.translationMatrix=this.transform.worldTransform;k.Color.shared.setValue(this._tintColor).premultiply(v).toArray(x.tint);q.shader.bind(t);q.geometry.bind(u,t);q.state.set(this.state);for(let y=0,
C=z.length;y<C;y++)this._renderDrawCallDirect(q,u.drawCalls[y])}_renderDrawCallDirect(q,t){const {texArray:u,type:v,size:x,start:z}=t;t=u.count;for(let y=0;y<t;y++)q.texture.bind(u.elements[y],y);q.geometry.draw(v,x,z)}_resolveDirectShader(q){var t=this.shader;const u=this.pluginName;if(!t){if(!h[u]){({maxTextures:t}=q.plugins[u]);const v=new Int32Array(t);for(let x=0;x<t;x++)v[x]=x;t={tint:new Float32Array([1,1,1,1]),translationMatrix:new k.Matrix,default:k.UniformGroup.from({uSamplers:v},!0)};h[u]=
new k.Shader(q.plugins[u]._shader.program,t)}t=h[u]}return t}_calculateBounds(){this.finishPoly();const q=this._geometry;if(q.graphicsData.length){var {minX:t,minY:u,maxX:v,maxY:x}=q.bounds;this._bounds.addFrame(this.transform,t,u,v,x)}}containsPoint(q){return this.worldTransform.applyInverse(q,n._TEMP_POINT),this._geometry.containsPoint(n._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this._tintColor.toNumber();for(let q=0;q<this.batches.length;q++){const t=this.batches[q];
t._tintRGB=k.Color.shared.setValue(this._tintColor).multiply(t._batchRGB).toLittleEndianNumber()}}}calculateVertices(){var q=this.transform._worldID;if(this._transformID!==q){this._transformID=q;var t=this.transform.worldTransform;q=t.a;var u=t.b,v=t.c,x=t.d,z=t.tx;t=t.ty;var y=this._geometry.points,C=this.vertexData,B=0;for(let w=0;w<y.length;w+=2){const E=y[w],H=y[w+1];C[B++]=q*E+v*H+z;C[B++]=x*H+u*E+t}}}closePath(){const q=this.currentPath;return q&&(q.closeStroke=!0,this.finishPoly()),this}setMatrix(q){return this._matrix=
q,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(q){this._geometry.refCount--;0===this._geometry.refCount&&this._geometry.dispose();this.currentPath=this._matrix=null;this._lineStyle.destroy();this._lineStyle=null;this._fillStyle.destroy();this.vertexData=this.shader=this._geometry=this._fillStyle=null;this.batches.length=0;this.batches=null;super.destroy(q)}};return n})();r.curves=d.curves;r._TEMP_POINT=new k.Point;
p.Graphics=r}
goog.provide("module$node_modules$$pixi$graphics$lib$Graphics");
goog.global. module$node_modules$$pixi$graphics$lib$Graphics=shadow.js.require(338, {});
