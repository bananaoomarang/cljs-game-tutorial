shadow$provide.module$node_modules$$pixi$compressed_textures$lib$loaders$detectCompressedTextures = function(global, require, module, exports) {
  function getCompressedTextureExtensions() {
    extensions = {s3tc:storedGl.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB:storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc:storedGl.getExtension("WEBGL_compressed_texture_etc"), etc1:storedGl.getExtension("WEBGL_compressed_texture_etc1"), pvrtc:storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc:storedGl.getExtension("WEBGL_compressed_texture_atc"), astc:storedGl.getExtension("WEBGL_compressed_texture_astc"), 
    bptc:storedGl.getExtension("EXT_texture_compression_bptc")};
  }
  var core = require("module$node_modules$$pixi$core$lib$index");
  let storedGl, extensions;
  global = {extension:{type:core.ExtensionType.DetectionParser, priority:2}, test:async() => {
    const gl = core.settings.ADAPTER.createCanvas().getContext("webgl");
    return gl ? (storedGl = gl, !0) : (console.warn("WebGL not available for compressed textures."), !1);
  }, add:async formats => {
    extensions || getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions) {
      extensions[extensionName] && textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats];
  }, remove:async formats => (extensions || getCompressedTextureExtensions(), formats.filter(f => !(f in extensions)))};
  core.extensions.add(global);
  exports.detectCompressedTextures = global;
};

goog.provide("module$node_modules$$pixi$compressed_textures$lib$loaders$detectCompressedTextures");
goog.global. module$node_modules$$pixi$compressed_textures$lib$loaders$detectCompressedTextures=shadow.js.require("module$node_modules$$pixi$compressed_textures$lib$loaders$detectCompressedTextures", {});

//# sourceMappingURL=module$node_modules$$pixi$compressed_textures$lib$loaders$detectCompressedTextures.js.map
