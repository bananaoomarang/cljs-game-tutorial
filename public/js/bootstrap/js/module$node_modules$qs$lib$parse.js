shadow$provide.module$node_modules$qs$lib$parse = function(global, require, module, exports) {
  var utils = require("module$node_modules$qs$lib$utils"), has = Object.prototype.hasOwnProperty, isArray = Array.isArray, defaults = {allowDots:!1, allowPrototypes:!1, allowSparse:!1, arrayLimit:20, charset:"utf-8", charsetSentinel:!1, comma:!1, decoder:utils.decode, delimiter:"\x26", depth:5, ignoreQueryPrefix:!1, interpretNumericEntities:!1, parameterLimit:1000, parseArrays:!0, plainObjects:!1, strictNullHandling:!1}, interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  }, parseArrayValue = function(val, options) {
    return val && "string" === typeof val && options.comma && -1 < val.indexOf(",") ? val.split(",") : val;
  }, parseValues = function(str, options) {
    var obj = {__proto__:null};
    str = (options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str).split(options.delimiter, Infinity === options.parameterLimit ? void 0 : options.parameterLimit);
    var skipIndex = -1, i, charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < str.length; ++i) {
        0 === str[i].indexOf("utf8\x3d") && ("utf8\x3d%E2%9C%93" === str[i] ? charset = "utf-8" : "utf8\x3d%26%2310003%3B" === str[i] && (charset = "iso-8859-1"), skipIndex = i, i = str.length);
      }
    }
    for (i = 0; i < str.length; ++i) {
      if (i !== skipIndex) {
        var part = str[i], bracketEqualsPos = part.indexOf("]\x3d"), pos = -1 === bracketEqualsPos ? part.indexOf("\x3d") : bracketEqualsPos + 1;
        -1 === pos ? (bracketEqualsPos = options.decoder(part, defaults.decoder, charset, "key"), pos = options.strictNullHandling ? null : "") : (bracketEqualsPos = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key"), pos = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }));
        pos && options.interpretNumericEntities && "iso-8859-1" === charset && (pos = interpretNumericEntities(pos));
        -1 < part.indexOf("[]\x3d") && (pos = isArray(pos) ? [pos] : pos);
        has.call(obj, bracketEqualsPos) ? obj[bracketEqualsPos] = utils.combine(obj[bracketEqualsPos], pos) : obj[bracketEqualsPos] = pos;
      }
    }
    return obj;
  };
  module.exports = function(str, opts) {
    if (opts) {
      if (null !== opts.decoder && void 0 !== opts.decoder && "function" !== typeof opts.decoder) {
        throw new TypeError("Decoder has to be a function.");
      }
      if ("undefined" !== typeof opts.charset && "utf-8" !== opts.charset && "iso-8859-1" !== opts.charset) {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      opts = {allowDots:"undefined" === typeof opts.allowDots ? defaults.allowDots : !!opts.allowDots, allowPrototypes:"boolean" === typeof opts.allowPrototypes ? opts.allowPrototypes : defaults.allowPrototypes, allowSparse:"boolean" === typeof opts.allowSparse ? opts.allowSparse : defaults.allowSparse, arrayLimit:"number" === typeof opts.arrayLimit ? opts.arrayLimit : defaults.arrayLimit, charset:"undefined" === typeof opts.charset ? defaults.charset : opts.charset, charsetSentinel:"boolean" === 
      typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel, comma:"boolean" === typeof opts.comma ? opts.comma : defaults.comma, decoder:"function" === typeof opts.decoder ? opts.decoder : defaults.decoder, delimiter:"string" === typeof opts.delimiter || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter, depth:"number" === typeof opts.depth || !1 === opts.depth ? +opts.depth : defaults.depth, ignoreQueryPrefix:!0 === opts.ignoreQueryPrefix, interpretNumericEntities:"boolean" === 
      typeof opts.interpretNumericEntities ? opts.interpretNumericEntities : defaults.interpretNumericEntities, parameterLimit:"number" === typeof opts.parameterLimit ? opts.parameterLimit : defaults.parameterLimit, parseArrays:!1 !== opts.parseArrays, plainObjects:"boolean" === typeof opts.plainObjects ? opts.plainObjects : defaults.plainObjects, strictNullHandling:"boolean" === typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling};
    } else {
      opts = defaults;
    }
    if ("" === str || null === str || "undefined" === typeof str) {
      return opts.plainObjects ? Object.create(null) : {};
    }
    for (var tempObj = "string" === typeof str ? parseValues(str, opts) : str, obj = opts.plainObjects ? Object.create(null) : {}, keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) {
      var key = keys[i];
      a: {
        var givenKey = key;
        key = tempObj[key];
        var options = opts, valuesParsed = "string" === typeof str;
        if (givenKey) {
          givenKey = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
          var brackets = /(\[[^[\]]*])/, child = /(\[[^[\]]*])/g, parent = (brackets = 0 < options.depth && brackets.exec(givenKey)) ? givenKey.slice(0, brackets.index) : givenKey, keys$jscomp$0 = [];
          if (parent) {
            if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) {
              key = void 0;
              break a;
            }
            keys$jscomp$0.push(parent);
          }
          for (parent = 0; 0 < options.depth && null !== (brackets = child.exec(givenKey)) && parent < options.depth;) {
            parent += 1;
            if (!options.plainObjects && has.call(Object.prototype, brackets[1].slice(1, -1)) && !options.allowPrototypes) {
              key = void 0;
              break a;
            }
            keys$jscomp$0.push(brackets[1]);
          }
          brackets && keys$jscomp$0.push("[" + givenKey.slice(brackets.index) + "]");
          givenKey = keys$jscomp$0;
          key = valuesParsed ? key : parseArrayValue(key, options);
          for (valuesParsed = givenKey.length - 1; 0 <= valuesParsed; --valuesParsed) {
            brackets = givenKey[valuesParsed], "[]" === brackets && options.parseArrays ? child = [].concat(key) : (child = options.plainObjects ? Object.create(null) : {}, keys$jscomp$0 = "[" === brackets.charAt(0) && "]" === brackets.charAt(brackets.length - 1) ? brackets.slice(1, -1) : brackets, parent = parseInt(keys$jscomp$0, 10), options.parseArrays || "" !== keys$jscomp$0 ? !isNaN(parent) && brackets !== keys$jscomp$0 && String(parent) === keys$jscomp$0 && 0 <= parent && options.parseArrays && 
            parent <= options.arrayLimit ? (child = [], child[parent] = key) : "__proto__" !== keys$jscomp$0 && (child[keys$jscomp$0] = key) : child = {0:key}), key = child;
          }
        } else {
          key = void 0;
        }
      }
      obj = utils.merge(obj, key, opts);
    }
    return !0 === opts.allowSparse ? obj : utils.compact(obj);
  };
};

goog.provide("module$node_modules$qs$lib$parse");
goog.global. module$node_modules$qs$lib$parse=shadow.js.require("module$node_modules$qs$lib$parse", {});

//# sourceMappingURL=module$node_modules$qs$lib$parse.js.map
