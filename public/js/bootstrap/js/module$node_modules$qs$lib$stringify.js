shadow$provide.module$node_modules$qs$lib$stringify = function(global, require, module, exports) {
  var getSideChannel = require("module$node_modules$side_channel$index"), utils = require("module$node_modules$qs$lib$utils"), formats = require("module$node_modules$qs$lib$formats"), has = Object.prototype.hasOwnProperty, arrayPrefixGenerators = {brackets:function(prefix) {
    return prefix + "[]";
  }, comma:"comma", indices:function(prefix, key) {
    return prefix + "[" + key + "]";
  }, repeat:function(prefix) {
    return prefix;
  }}, isArray = Array.isArray, push = Array.prototype.push, pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  }, toISO = Date.prototype.toISOString;
  global = formats["default"];
  var defaults = {addQueryPrefix:!1, allowDots:!1, charset:"utf-8", charsetSentinel:!1, delimiter:"\x26", encode:!0, encoder:utils.encode, encodeValuesOnly:!1, format:global, formatter:formats.formatters[global], indices:!1, serializeDate:function(date) {
    return toISO.call(date);
  }, skipNulls:!1, strictNullHandling:!1}, sentinel = {}, stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    for (var obj = object, tmpSc = sideChannel, step = 0, findFlag = !1; void 0 !== (tmpSc = tmpSc.get(sentinel)) && !findFlag;) {
      var pos = tmpSc.get(object);
      step += 1;
      if ("undefined" !== typeof pos) {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        }
        findFlag = !0;
      }
      "undefined" === typeof tmpSc.get(sentinel) && (step = 0);
    }
    "function" === typeof filter ? obj = filter(prefix, obj) : obj instanceof Date ? obj = serializeDate(obj) : "comma" === generateArrayPrefix && isArray(obj) && (obj = utils.maybeMap(obj, function(value) {
      return value instanceof Date ? serializeDate(value) : value;
    }));
    if (null === obj) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
      }
      obj = "";
    }
    if ("string" === typeof obj || "number" === typeof obj || "boolean" === typeof obj || "symbol" === typeof obj || "bigint" === typeof obj || utils.isBuffer(obj)) {
      return encoder ? (object = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format), [formatter(object) + "\x3d" + formatter(encoder(obj, defaults.encoder, charset, "value", format))]) : [formatter(prefix) + "\x3d" + formatter(String(obj))];
    }
    tmpSc = [];
    if ("undefined" === typeof obj) {
      return tmpSc;
    }
    "comma" === generateArrayPrefix && isArray(obj) ? (encodeValuesOnly && encoder && (obj = utils.maybeMap(obj, encoder)), findFlag = [{value:0 < obj.length ? obj.join(",") || null : void 0}]) : isArray(filter) ? findFlag = filter : (findFlag = Object.keys(obj), findFlag = sort ? findFlag.sort(sort) : findFlag);
    prefix = commaRoundTrip && isArray(obj) && 1 === obj.length ? prefix + "[]" : prefix;
    for (pos = 0; pos < findFlag.length; ++pos) {
      var key = findFlag[pos], value = "object" === typeof key && "undefined" !== typeof key.value ? key.value : obj[key];
      if (!skipNulls || null !== value) {
        key = isArray(obj) ? "function" === typeof generateArrayPrefix ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(tmpSc, stringify(value, key, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, "comma" === generateArrayPrefix && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
      }
    }
    return tmpSc;
  };
  module.exports = function(object, opts) {
    if (opts) {
      if (null !== opts.encoder && "undefined" !== typeof opts.encoder && "function" !== typeof opts.encoder) {
        throw new TypeError("Encoder has to be a function.");
      }
      var options = opts.charset || defaults.charset;
      if ("undefined" !== typeof opts.charset && "utf-8" !== opts.charset && "iso-8859-1" !== opts.charset) {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if ("undefined" !== typeof opts.format) {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format], filter = defaults.filter;
      if ("function" === typeof opts.filter || isArray(opts.filter)) {
        filter = opts.filter;
      }
      options = {addQueryPrefix:"boolean" === typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix, allowDots:"undefined" === typeof opts.allowDots ? defaults.allowDots : !!opts.allowDots, charset:options, charsetSentinel:"boolean" === typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel, delimiter:"undefined" === typeof opts.delimiter ? defaults.delimiter : opts.delimiter, encode:"boolean" === typeof opts.encode ? opts.encode : defaults.encode, encoder:"function" === 
      typeof opts.encoder ? opts.encoder : defaults.encoder, encodeValuesOnly:"boolean" === typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly, filter, format, formatter, serializeDate:"function" === typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate, skipNulls:"boolean" === typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls, sort:"function" === typeof opts.sort ? opts.sort : null, strictNullHandling:"boolean" === typeof opts.strictNullHandling ? 
      opts.strictNullHandling : defaults.strictNullHandling};
    } else {
      options = defaults;
    }
    if ("function" === typeof options.filter) {
      format = options.filter, object = format("", object);
    } else if (isArray(options.filter)) {
      var objKeys = format = options.filter;
    }
    format = [];
    if ("object" !== typeof object || null === object) {
      return "";
    }
    formatter = arrayPrefixGenerators[opts && opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : opts && "indices" in opts ? opts.indices ? "indices" : "repeat" : "indices"];
    if (opts && "commaRoundTrip" in opts && "boolean" !== typeof opts.commaRoundTrip) {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    opts = "comma" === formatter && opts && opts.commaRoundTrip;
    objKeys || (objKeys = Object.keys(object));
    options.sort && objKeys.sort(options.sort);
    filter = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      options.skipNulls && null === object[key] || pushToArray(format, stringify(object[key], key, formatter, opts, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, filter));
    }
    objKeys = format.join(options.delimiter);
    object = !0 === options.addQueryPrefix ? "?" : "";
    options.charsetSentinel && (object = "iso-8859-1" === options.charset ? object + "utf8\x3d%26%2310003%3B\x26" : object + "utf8\x3d%E2%9C%93\x26");
    return 0 < objKeys.length ? object + objKeys : "";
  };
};

goog.provide("module$node_modules$qs$lib$stringify");
goog.global. module$node_modules$qs$lib$stringify=shadow.js.require("module$node_modules$qs$lib$stringify", {});

//# sourceMappingURL=module$node_modules$qs$lib$stringify.js.map
