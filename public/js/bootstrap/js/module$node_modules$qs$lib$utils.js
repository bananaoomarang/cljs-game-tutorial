shadow$provide.module$node_modules$qs$lib$utils = function(global, require, module, exports) {
  var formats = require("module$node_modules$qs$lib$formats"), has = Object.prototype.hasOwnProperty, isArray = Array.isArray, hexTable = function() {
    for (var array = [], i = 0; 256 > i; ++i) {
      array.push("%" + ((16 > i ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }(), arrayToObject = function(source, options) {
    options = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      "undefined" !== typeof source[i] && (options[i] = source[i]);
    }
    return options;
  };
  module.exports = {arrayToObject, assign:function(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  }, combine:function(a, b) {
    return [].concat(a, b);
  }, compact:function(value) {
    for (var queue = [{obj:{o:value}, prop:"o"}], refs = [], i = 0; i < queue.length; ++i) {
      var item = queue[i];
      item = item.obj[item.prop];
      for (var keys = Object.keys(item), j = 0; j < keys.length; ++j) {
        var key = keys[j], val = item[key];
        "object" === typeof val && null !== val && -1 === refs.indexOf(val) && (queue.push({obj:item, prop:key}), refs.push(val));
      }
    }
    for (; 1 < queue.length;) {
      if (refs = queue.pop(), i = refs.obj[refs.prop], isArray(i)) {
        item = [];
        for (keys = 0; keys < i.length; ++keys) {
          "undefined" !== typeof i[keys] && item.push(i[keys]);
        }
        refs.obj[refs.prop] = item;
      }
    }
    return value;
  }, decode:function(str, decoder, charset) {
    str = str.replace(/\+/g, " ");
    if ("iso-8859-1" === charset) {
      return str.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }, encode:function(str, defaultEncoder, charset, kind, format) {
    if (0 === str.length) {
      return str;
    }
    defaultEncoder = str;
    "symbol" === typeof str ? defaultEncoder = Symbol.prototype.toString.call(str) : "string" !== typeof str && (defaultEncoder = String(str));
    if ("iso-8859-1" === charset) {
      return escape(defaultEncoder).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    str = "";
    for (charset = 0; charset < defaultEncoder.length; ++charset) {
      kind = defaultEncoder.charCodeAt(charset), 45 === kind || 46 === kind || 95 === kind || 126 === kind || 48 <= kind && 57 >= kind || 65 <= kind && 90 >= kind || 97 <= kind && 122 >= kind || format === formats.RFC1738 && (40 === kind || 41 === kind) ? str += defaultEncoder.charAt(charset) : 128 > kind ? str += hexTable[kind] : 2048 > kind ? str += hexTable[192 | kind >> 6] + hexTable[128 | kind & 63] : 55296 > kind || 57344 <= kind ? str += hexTable[224 | kind >> 12] + hexTable[128 | kind >> 
      6 & 63] + hexTable[128 | kind & 63] : (charset += 1, kind = 65536 + ((kind & 1023) << 10 | defaultEncoder.charCodeAt(charset) & 1023), str += hexTable[240 | kind >> 18] + hexTable[128 | kind >> 12 & 63] + hexTable[128 | kind >> 6 & 63] + hexTable[128 | kind & 63]);
    }
    return str;
  }, isBuffer:function(obj) {
    return obj && "object" === typeof obj ? !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj)) : !1;
  }, isRegExp:function(obj) {
    return "[object RegExp]" === Object.prototype.toString.call(obj);
  }, maybeMap:function(val, fn) {
    if (isArray(val)) {
      for (var mapped = [], i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  }, merge:function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if ("object" !== typeof source) {
      if (isArray(target)) {
        target.push(source);
      } else if (target && "object" === typeof target) {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = !0;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || "object" !== typeof target) {
      return [target].concat(source);
    }
    var mergeTarget = target;
    isArray(target) && !isArray(source) && (mergeTarget = arrayToObject(target, options));
    return isArray(target) && isArray(source) ? (source.forEach(function(item, i) {
      if (has.call(target, i)) {
        var targetItem = target[i];
        targetItem && "object" === typeof targetItem && item && "object" === typeof item ? target[i] = merge(targetItem, item, options) : target.push(item);
      } else {
        target[i] = item;
      }
    }), target) : Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      has.call(acc, key) ? acc[key] = merge(acc[key], value, options) : acc[key] = value;
      return acc;
    }, mergeTarget);
  }};
};

goog.provide("module$node_modules$qs$lib$utils");
goog.global. module$node_modules$qs$lib$utils=shadow.js.require("module$node_modules$qs$lib$utils", {});

//# sourceMappingURL=module$node_modules$qs$lib$utils.js.map
